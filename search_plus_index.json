{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction 关于我 go Go 1.13 中 Go command 修改 Go 基础 iOS 上传应用时，卡在 Authenticating with the App Store 类的初始化方法 如何创建一个公有 Pod 库 App 沙盒 Block 的声明方式 Rac EventBus RxJava 动态更换 App 图标 SiriKit 人机界面指南 GCD 同步异步与串行并行 CocoaPods 安装及错误处理 iOS 消息转发机制 NSMethodSignature 和 NSInvocation 常见的编译失败 Hook 系统代理方法 二维码生成及定制 WKWebView 使用及注意事项 面试啊面试~ double 转 NSString 出现精度异常 Widget 开发-开发篇 Widget 开发-配置篇 读取一个带有加密印章的 PDF LeetCode 1. 两数之和 2. 有效的括号 Mac 升级 Git 版本 Charles 安装证书 iTerm2 一个更好用的终端 Mac 系统重装 Ubuntu Ubuntu 安装 MySQL 随见随学 如何评判算法好坏 如何保持 SSH 服务不掉线 Shell 入门教程 AppleScript 入门与实践 搭建 Hexo Blog 基础知识 常用的日期格式化格式 RESTful 笔记 HTTP 状态码 简明扼要带你学位运算 URI、URL的差异与联系 Copyright © zhang peng 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-07-22 10:44:14 "},"me.html":{"url":"me.html","title":"关于我","keywords":"","body":"关于我 张鹏 QQ： 296197662 邮箱： zhangpeng.0304@aliyun.com 博客： http://articles.zhangpeng.site GitHub： https://github.com/fullstack-zhangpeng 简介 主要是面向兴趣开发。 客户端 -> 钻石选手 服务端 -> 黄金选手 前端 -> 白银选手 2015/08 - 至今　　　　iOS 开发工程师 2020/04 - 至今　　　　服务端开发工程师 致谢 感谢您花时间阅读，期待能有机会和您共事。 Copyright © zhang peng 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-07-22 10:44:14 "},"go/go-command.html":{"url":"go/go-command.html","title":"Go 1.13 中 Go command 修改","keywords":"","body":"Go 1.13 中 Go command 修改 go1.13 已经发布了一个多月了，本次的大部分修改都是工具链、运行时和核心库。而本文主要是记录的命令行的修改。 go env go env 添加几个新的参数，使修改环境变量变得更方便快捷。 -w 设置环境变量，通过此方式设置的默认值存储在 os.UserConfigDir() 中的 go/env 文件中。 -u 取消以前设置的默认变量 go version 现在 go version 命令的参数既可以是可执行文件又可以是项目目录。如果在 go version 命令中加上 -m 参数，则会打印可执行文件的引用模块的相关版本信息。 可执行文件 打印用于构建该可执行文件的 go sdk 版本。 ➜ GoProject go version ./GoProject ./GoProject: go1.13.1 ➜ GoProject go version -m ./GoProject ./GoProject: go1.13.1 path GoProject mod GoProject (devel) dep github.com/gin-contrib/sse v0.0.0-20190301062529-5545eab6dad3 h1:t8FVkw33L+wilf2QiWkw0UV77qRpcH/JHPKGpKa2E8g= dep github.com/gin-gonic/gin v1.4.0 h1:3tMoCCfM7ppqsR0ptz/wi1impNpT7/9wQtMZ8lr1mCQ= dep github.com/golang/protobuf v1.3.1 h1:YF8+flBXS5eO826T4nzqPrxfhQThhXl0YzfuUPu4SBg= dep github.com/mattn/go-isatty v0.0.7 h1:UvyT9uN+3r7yLEYSlJsbQGdsaB/a0DlgWP3pql6iwOc= dep github.com/ugorji/go v1.1.4 h1:j4s+tAvLfL3bZyefP2SEWmhBzmuIlH/eqNuPdFPgngw= dep gopkg.in/go-playground/validator.v8 v8.18.2 h1:lFB4DoMU6B626w8ny76MV7VX6W2VHct2GVOI3xgiMrQ= dep gopkg.in/yaml.v2 v2.2.2 h1:ZCJp+EgiOT7lHqUV2J862kp8Qj64Jo6az82+3Td9dZw= 项目目录 打印目录及其子目录中包含的可执行文件的信息。 ➜ GoProject go version . GoProject: go1.13.1 ➜ GoProject go version -m . GoProject: go1.13.1 path GoProject mod GoProject (devel) dep github.com/gin-contrib/sse v0.0.0-20190301062529-5545eab6dad3 h1:t8FVkw33L+wilf2QiWkw0UV77qRpcH/JHPKGpKa2E8g= dep github.com/gin-gonic/gin v1.4.0 h1:3tMoCCfM7ppqsR0ptz/wi1impNpT7/9wQtMZ8lr1mCQ= dep github.com/golang/protobuf v1.3.1 h1:YF8+flBXS5eO826T4nzqPrxfhQThhXl0YzfuUPu4SBg= dep github.com/mattn/go-isatty v0.0.7 h1:UvyT9uN+3r7yLEYSlJsbQGdsaB/a0DlgWP3pql6iwOc= dep github.com/ugorji/go v1.1.4 h1:j4s+tAvLfL3bZyefP2SEWmhBzmuIlH/eqNuPdFPgngw= dep gopkg.in/go-playground/validator.v8 v8.18.2 h1:lFB4DoMU6B626w8ny76MV7VX6W2VHct2GVOI3xgiMrQ= dep gopkg.in/yaml.v2 v2.2.2 h1:ZCJp+EgiOT7lHqUV2J862kp8Qj64Jo6az82+3Td9dZw= go build -trimpath 从编译的可执行文件中删除所有文件系统路径，以提高构建的可重复性。 -o 如果传入一个目录，则会将可执行文件写入该文件夹。 附件 Go 1.13 Release Notes UserConfigDir Title: Go 1.13 中 Go command 修改 Date: 2020.05.07 Author: zhangpeng Github: https://github.com/fullstack-zhangpeng Copyright © zhang peng 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-07-22 10:44:14 "},"go/go.html":{"url":"go/go.html","title":"Go 基础","keywords":"","body":"Go 基础 环境配置 下载安装包 配置环境变量 在您所使用的 shell 对应的配置文件中，添加下面的内容： export GOROOT=\"/usr/local/go\" export GOPATH=\"$HOME/go\" export PATH=$PATH:$GOPATH/bin # Enable the go modules feature export GO111MODULE=auto # Set the GOPROXY environment variable export GOPROXY=https://goproxy.io 完成上面的操作后，在终端输入 go env，输出下面内容，就表示 go 环境配置完成： ~ go env GOARCH=\"amd64\" GOBIN=\"\" GOCACHE=\"/Users/zhangpeng/Library/Caches/go-build\" GOEXE=\"\" GOFLAGS=\"\" GOHOSTARCH=\"amd64\" GOHOSTOS=\"darwin\" GOOS=\"darwin\" GOPATH=\"/Users/zhangpeng/go\" GOPROXY=\"https://goproxy.io\" GORACE=\"\" GOROOT=\"/usr/local/go\" GOTMPDIR=\"\" GOTOOLDIR=\"/usr/local/go/pkg/tool/darwin_amd64\" GCCGO=\"gccgo\" CC=\"clang\" CXX=\"clang++\" CGO_ENABLED=\"1\" GOMOD=\"\" CGO_CFLAGS=\"-g -O2\" CGO_CPPFLAGS=\"\" CGO_CXXFLAGS=\"-g -O2\" CGO_FFLAGS=\"-g -O2\" CGO_LDFLAGS=\"-g -O2\" PKG_CONFIG=\"pkg-config\" GOGCCFLAGS=\"-fPIC -m64 -pthread -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fdebug-prefix-map=/var/folders/sk/qbbrttxx2j1d7bqf02wh90zm0000gn/T/go-build233880756=/tmp/go-build -gno-record-gcc-switches -fno-common\" GOROOT & GOPATH GOROOT Go 的安装目录 内置的包和函数，如 fmt 、math、strings 等都存储在这个目录的 src 文件夹中 GOPATH Go 的工作目录 src: 存放源代码。按照 Go 语言约定，go run，go install 等命令默认会在此路径下执行； pkg: 存放编译时生成的中间文件（ *.a ）； bin: 存放编译后生成的可执行文件 （ 在项目内执行 go install，会在 bin 目录下生成一个可执行文件）。 常用命令 go run 编译并执行，只能作用于命令源码文件，一般用于开发中快速测试。上文我们通过执行 go run test.go ，完成了程序的编译运行。 go build 编译代码包或者源码文件。如果带上代码包名，则表示编译指定的代码包；如果带上源码文件，则表示编译指定源码文件。 go get 下载第三方代码包并编译安装 ，需要注意的是，它会下载安装到 GOPATH 环境变量配置的第一个工作区中。 go install 这个命令用于编译安装，可以作用于 main 包和非 main 包，然后将编译后的生成的执行文件存放到工程的 bin 目录下，将生成的归档文件（即静态链接库）存放到工程的 pkg 目录下。使用方式类似于 go build，可以在某个代码包目录下直接使用，也可以指定代码包使用。 go env 用于打印 GO 语言的环境信息，如 GOPATH 是工作区目录，GOROOT 是 GO 语言安装目录，GOBIN 是通过 go install 命令生成可执行文件的存放目录（默认是当前工作区的 bin 目录下），GOEXE 为生成可执行文件的后缀 数据类型 布尔型，整型，浮点型，指针类型（Pointer）、数组类型、结构化类型(struct)、Channel 类型、函数类型、切片类型、接口类型（interface）、Map 类型 // 布尔型 bool // ------------------------------------------------------- // 整型 int8 int16 int32 int64 uint8 uint16 uint32 uint64 // ------------------------------------------------------- // 浮点型 float32 float64 // ------------------------------------------------------- // 字符串 string // ------------------------------------------------------- // 结构体，结构体是由一系列具有相同类型或不同类型的数据构成的数据集合 // 用结构体可以表示一个具有某一特征的对象 type identifier struct { field1 type1 field2 type2 } // ------------------------------------------------------- // 数组，有序的元素序列 // 可以通过访问数组下标即可对数组元素进行赋值 var variable_name [SIZE] variable_type // ------------------------------------------------------- // 切片，类似\"动态数组\"结构的数据类型 // 本质是一个数据结构，实现了对数组操作的封装。 var identifier []type // ------------------------------------------------------- // map // 如果不初始化 map，那么就会创建一个 nil map。nil map 不能用来存放键值对 // 对于 map 类型，一定要进行初始化再赋值 var map_variable map[key_data_type]value_data_type 变量声明赋值 先声明，后赋值 // 声明变量，变量名放在类型前 var name string // 赋值 name = \"test\" 声明并赋值 // 编译器会根据值自行判定变量类型 // 方式 1 var name = \"test\" // 方式 2 name := \"test\" 常用类型初始化方式 // 结构体 type Person struct { name string // 姓名 age uint32 // 年龄 birth string // 出生日期 用 yyyy/mm/dd 格式的字符串表示 height float32 // 身高 weight float32 // 体重 } // 方式1，变量 t 是一个指向 Person 的指针，此时结构体字段的值是它们所属类型的零值 t := new(Person) // 方式2，底层仍然会调用 new ()，这里值的顺序必须按照字段顺序来写 person : &Person {name : \"juejin\", age : 12} //---------------------------------- // 初始化数组 var array = [5]string{ \"go\", \"java\", \"c++\" } array = [10] int64 {0, 1, 2, 3, 4, 5, 6, 7, 8, 9} //---------------------------------- // 初始化 int64 类型的切片 array = make([]int64, 10) //---------------------------------- // map dataMap := make(map[string]string) 条件语句 /* * condition: 关系表达式或逻辑表达式，循环控制条件 */ if condition { } eg. if a == 10 { /* 如果条件为 true 则执行以下语句 */ fmt.Println(\"a == 10\" ) } /* * statement: 可选语句部分，在条件判断之前运行 * condition: 关系表达式或逻辑表达式，判断条件 */ if statement; condition { } eg. if a := 1 ; a 循环语句 方式 1 /* * init： 一般为赋值表达式，给控制变量赋初值； * condition： 关系表达式或逻辑表达式，循环控制条件； * post： 一般为赋值表达式，给控制变量增量或减量。 */ for init; condition; post { } eg. for i :=1 ; i 方式2 /* * condition： 关系表达式或逻辑表达式，循环控制条件 */ for condition { } eg. for 0 == 0 {} for true {} 方式3 for { } eg. for { // 服务器监听 8080 端口 server.Listen(8080) } 函数 go 语言中的函数是支持多返回值的 func function_name( [parameter list] ) [return_types] { // 函数体 } eg. // 此函数实现了取两个数最大值的功能 func max(a int32, b int32) int32 { if a > b { return a } else { return b } } // 此函数实现了取两个数最大值和最小值的功能 func getMaxAndMin(a int32, b int32) (int32, int32) { if a > b { return a, b } else { return b, a } } go 语言还有一种特殊的函数，叫做方法。一个方法就是一个包含了接受者的函数，接受者可以是命名类型或者结构体类型的一个值或者是一个指针。 func (variable_name variable_data_type) function_name() [return_type]{ /* 函数体*/ } // 我们用 面向对象的思想实现一个封装的结构体 type Person struct{ name string // 姓名 age uint32 // 年龄 } // 获取姓名 func (p *Person) GetName() string{ return p.name } // 获取年龄 func (p *Person) GetAge() uint32{ return p.age } // 设置姓名 func (p *Person) SetName(name string) { p.name = name } // 设置年龄 func (p *Person) SetAge(age uint32) { p.age = age } 异常处理 结合自定义的 error 类型给出一个使用 panic 和 recover 的完整例子： package main import ( \"fmt\" ) // 定义除法运算函数 func Devide(num1, num2 int) int { if num2 == 0 { panic(\"num cannot be 0\") } else { return num1 / num2 } } func main() { var a, b int fmt.Scanf(\"%d %d\", &a, &b) defer func() { if r := recover(); r != nil { fmt.Printf(\"panic的内容%v\\n\", r) } }() rs := Devide(a, b) fmt.Println(\"结果是：\", rs) } 权限控制 在 go 语言中，是通过约定来实现权限控制的。变量和方法都遵守驼峰式命名。变量和方法的首字母大写，相当于 public，变量和方法的首字母小写，相当于 private。同一个包中访问，相当于 default ，由于 go 语言没有继承，所以也没有 protected 权限。 继承 go 语言是没有继承的。但是 go 语言可以通过结构体之间的组合来实现类似继承的效果。 package main import \"fmt\" type oo struct { inner ss1 string ss2 int ss3 bool } type inner struct { ss4 string } func (i *inner) testMethod () { fmt.Println(\"testMethod is called!!!\") } func main() { oo1 := new(oo) fmt.Println(\"ss4无值：\"+oo1.ss4) oo1.ss4 = \"abc\" fmt.Println(\"ss4已赋值\"+oo1.ss4) oo1.testMethod()//继承调用 oo1.inner.testMethod()//继承调用 这里也可以重写 } 多态 在 go 语言中，只要某个 struct 实现了某个 interface 的所有方法，那么我们就认为这个 struct 实现了这个类。 package main import ( \"fmt\" ) type Person interface { Sing () } type Girl struct { Name string } type Boy struct { Name string } func (this *Girl) Sing () { fmt.Println(\"Hi, I am \" + this.Name) } func (this *Boy) Sing () { fmt.Println(\"Hi, I am \" + this.Name) } func main() { g := &Girl{\"Lucy\"} b := &Boy{\"Dave\"} p := map[int]Person{} p[0] = g p[1] = b for _, v := range p { v.Sing() } } Title: Go 基础 Date: 2019.07.20 Author: zhangpeng Github: https://github.com/fullstack-zhangpeng Copyright © zhang peng 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-07-22 10:44:14 "},"ios/authenticating-with-the-app-store.html":{"url":"ios/authenticating-with-the-app-store.html","title":"上传应用时，卡在 Authenticating with the App Store","keywords":"","body":"上传应用时，卡在 Authenticating with the App Store 本文主要解决的是在上传应用时，卡在 Authenticating with the App Store... 的问题。 问题分析 综合网上各种解决此问题的方案，我这边猜测卡住的原因如下： 在上传 ipa 时，需要使用很多内置的资源，而这些资源是需要下载的。因为某种原因（例如 GFW，或者个人网络原因）下载缓慢或失败，都会造成卡死在这一步。 解决方案 下载所需的文件 链接: com.apple.amp.itmstransporter.zip 提取码: vx8z 修改文件中的内容 找到 obr/2.0.0/repository.xml 这个文件。用文本编辑器打开，切记一定要用文本编辑器之类的打开，不要直接双击用 Xcode 打开，因为文件太大，Xcode 会崩溃。 在文件中搜索 zhangpeng，全部替换为你电脑登录的用户名。 替换文件 将 ~/Library/Caches 文件中的 com.apple.amp.itmstransporter 完全删除。然后将上面的解压后的文件夹放入 ~/Library/Caches，退出 Xcode 或 Transport，重新上传即可。 Title: 上传应用时，卡在 Authenticating with the App Store Date: 2020.05.26 Author: zhangpeng Github: https://github.com/fullstack-zhangpeng Copyright © zhang peng 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-07-22 10:44:14 "},"ios/initializer.html":{"url":"ios/initializer.html","title":"类的初始化方法","keywords":"","body":"类的初始化方法 原文链接：深入了解 iOS 的初始化，本文是阅读以后的摘抄。 类（结构体、枚举）的初始化有两种初始化器（初始化方法）： 指定初始化器（Designated Initializers ） 便利初始化器（Convenience Initializers） 指定初始化器 指定构造器是类中最主要的构造器。一个指定构造器将初始化类中提供的所有属性，并调用合适的父类构造器让构造过程沿着父类链继续往上进行。 便利初始化器 便利初始化器是类（结构体、枚举）的次要初始化器，作用是使类（结构体、枚举）在初始化时更方便设置相关的属性（成员变量）。便利初始化器里面最后都需要调用自身的指定初始化器。 核心原则 必须至少有一个指定初始化器，在指定初始化器里保证所有非可选类型属性都得到正确的初始化（有值） 便利初始化器必须调用其他初始化器，使得最后肯定会调用指定初始化器 如果文字不好理解，可以根据下面的图，进行理解： Objective-C 和 Swift 的差异 Objective-C Objective-C 在初始化时，会自动给每个属性（成员变量）赋值为 0 或者 nil，没有强制要求额外为每个属性（成员变量）赋值，方便的同时也缺少了代码的安全性。 Objective-C 中的指定初始化器会在后面被 NS_DESIGNATED_INITIALIZER 修饰，以下为 NSObject 和 UIView 的指定初始化器： // NSObject @interface NSObject - (instancetype)init #if NS_ENFORCE_NSOBJECT_DESIGNATED_INITIALIZER NS_DESIGNATED_INITIALIZER #endif ; @end // UIView @interface UIView : UIResponder - (instancetype)initWithFrame:(CGRect)frame NS_DESIGNATED_INITIALIZER; - (nullable instancetype)initWithCoder:(NSCoder *)coder NS_DESIGNATED_INITIALIZER; @end 无论继承自什么类，都经常需要新的初始化方法，而这个新的初始化方法其实就是新的指定初始化器。如果存在一个新的指定初始化器，那么原来的指定初始化器就会自动退化成便利初始化器。为了遵循必须要调用指定初始化器的规则，就必须重写旧的定初始化器，在里面调用新的指定初始化器，这样就能确保所有属性（成员变量）被初始化。 举例 由于UIView拥有新的指定初始化器 -initWithFrame:，导致父类 NSObject 的指定初始化器 -init 退化成便利初始化器。所以当调用 [[UIView alloc] init] 时，-init 里面必然调用了 -initWithFrame:。 建议 当存在一个新的指定初始化器的时候，推荐在方法名后面加上 NS_DESIGNATED_INITIALIZER，主动告诉编译器有一个新的指定初始化器，这样就可以使用 Xcode 自带的Analysis功能分析，找出初始化过程中可能存在的漏洞。 如果不想去重写旧的指定初始化器，但又不想存在漏洞和隐患，那么可以使用 NS_UNAVAILABLE 把旧的指定初始化器都废弃，外界就无法调用旧的指定初始化器。 Swift 相对于 Objective-C，Swift 多了一些规则： 初始化的时候需要保证类（结构体、枚举）的所有非可选类型属性都会有值，否则会报错 在没有给所有非可选类型属性赋值（初始化完成）之前，不能调用self相关的任何东西，例如：调用实例属性，调用实例方法 不存在继承 这种情况处理就十分简单，自己里面的 init 方法就是它的指定初始化器，而且可以随意创建多个它的指定初始化器。如果需要创建便利初始化器，则在方法名前面加上 convenience，且在里面必须调用其他初始化器，使得最后肯定调用指定初始化器。 class Student: Person { var score: Double = 100 } 存在继承 如果子类没有新的非可选类型属性，或者保证所有非可选类型属性都已经有默认值，则可以直接继承父类的指定初始化器和便利初始化器。 如果子类有新的非可选类型属性，或者无法保证所有非可选类型属性都已经有默认值，则需要新创建一个指定初始化器，或者重写父类的指定初始化器。 新创建一个指定初始化器，会覆盖父类的指定初始化器，需要先给当前类所有非可选类型属性赋值，然后再调用父类的指定初始化器 重写父类的指定初始化器，需要先给当前类所有非可选类型属性赋值，然后再调用父类的指定初始化器 在保证子类有指定初始化器，才能创建便利初始化器，且在便利初始化器里面必须调用指定初始化器 class Student: Person { var score: Double // 新的指定初始化器，如果有新的指定初始化器，就不会继承父类的所有初始化器，除非重写 init(name: String, age: Int, score: Double) { self.score = score super.init(name: name, age: age) } // 重写父类的指定初始化器，如果不重写，则子类不存在这个方法 override init(name: String, age: Int) { score = 100 super.init(name: name, age: age) } // 便利初始化器 convenience init(name: String) { // 必须要调用自己的指定初始化器 self.init(name: name, age: 10, score: 100) } } 需要注意的是，如果子类重写父类所有指定初始化器，则会继承父类的便利初始化器。原因也是很简单，因为父类的便利初始化器，依赖于自己的指定初始化器。 可失败的初始化器 可失败的初始化器（Failable Initializers），表示在某些情况下会创建实例失败。只有在表示创建失败的时候才有返回值，并且返回值为 nil。 子类可以把父类的可失败的初始化器重写为不可失败的初始化器，但不能把父类的不可失败的初始化器重写为可失败的初始化器。 class Animal { let name: String // 可失败的初始化器，如果把 ! 换成 ?，则为隐式的可失败的初始化器 init?(name: String) { if name.isEmpty { return nil } self.name = name } } class Dog: Animal { override init(name: String) { if name.isEmpty { super.init(name: \"旺财\")! } else { super.init(name: name)! } } } 必须的初始化器 可以使用 required 修饰初始化器，来指定子类必须实现该初始化器。需要注意的是，如果子类可以直接继承父类的指定初始化器和便利初始化器，也就可以不用额外实现required修饰的初始化器。 Title: 类的初始化方法 Date: 2019.12.05 Author: zhangpeng Github: https://github.com/fullstack-zhangpeng Copyright © zhang peng 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-07-22 10:44:14 "},"ios/create-pod.html":{"url":"ios/create-pod.html","title":"如何创建一个公有 Pod 库","keywords":"","body":"如何创建一个公有 Pod 库 注意： 文中使用 {} 包裹的位置都需要根据您自身情况进行设置。 如果您已经是 COCOAPODS 用户，请直接跳到第二节。 注册 COCOAPODS 用户 注册 Session $ pod trunk register {YOURMAIL} '{YOURNAME}' --verbose opening connection to trunk.cocoapods.org:443... opened starting SSL for trunk.cocoapods.org:443... SSL established, protocol: TLSv1.2, cipher: ECDHE-RSA-AES128-GCM-SHA256 \"HTTP/1.1 201 Created\\r\\n\" -> \"Date: Thu, 20 Jun 2019 14:17:48 GMT\\r\\n\" -> \"Connection: keep-alive\\r\\n\" -> \"Strict-Transport-Security: max-age=31536000\\r\\n\" -> \"Content-Type: application/json\\r\\n\" -> \"Content-Length: 192\\r\\n\" -> \"X-Content-Type-Options: nosniff\\r\\n\" -> \"Server: thin 1.6.2 codename Doc Brown\\r\\n\" -> \"Via: 1.1 vegur\\r\\n\" -> \"\\r\\n\" reading 192 bytes... -> \"{\\\"created_at\\\":\\\"2019-06-20 14:17:48 UTC\\\",\\\"valid_until\\\":\\\"2019-10-26 14:17:48 UTC\\\",\\\"verified\\\":false,\\\"created_from_ip\\\":\\\"223.104.3.12\\\",\\\"description\\\":null,\\\"token\\\":\\\"xxxxxxxxxx\\\"}\" read 192 bytes Conn keep-alive [!] Please verify the session by clicking the link in the verification email that has been sent to YOURMAIL 去邮箱点击验证链接 此时您的邮箱中应该有一封主题是 [CocoaPods] Confirm your session. 的邮件，点击邮件中的链接进行验证。 验证是否注册成功 下面内容，表示您已经注册成功。 $ pod trunk me - Name: YOURNAME - Email: YOURMAIL - Since: May 23rd, 2018 03:02 - Pods: - PodName - Sessions: - June 20th, 08:17 - October 26th, 08:39. IP: xxx.xxx.xxx.xxx 创建公有 Pod 库 创建一个 Git 仓库 创建过程请自行百度，谢谢！！！如果是在搜不到，那就私信我吧！😓 假设我们已经成功创建了一个仓库, 关键信息如下： 仓库主页进入您创建的仓库后，地址栏中的地址:https://github.com/{YOURGITHUBNAME}/{YOURPODNAME} git 地址点击 Clone or download 按钮，就可以看到了。我们选择 HTTPS 地址，别问为什么，因为 CocoaPods 要求:https://github.com/{YOURGITHUBNAME}/{YOURPODNAME}.git 创建 Pod 库 在终端中执行: pod lib create {YOURPODNAME}，接下来按照提示，根据自己的情况进行选择就可以了。 $ pod lib create {YOURPODNAME} Cloning `https://github.com/CocoaPods/pod-template.git` into `YOURPODNAME`. Configuring YOURPODNAME template. security: SecKeychainSearchCopyNext: The specified item could not be found in the keychain. ------------------------------ To get you started we need to ask a few questions, this should only take a minute. If this is your first time we recommend running through with the guide: - https://guides.cocoapods.org/making/using-pod-lib-create.html ( hold cmd and click links to open in a browser. ) What platform do you want to use?? [ iOS / macOS ] > {iOS} What language do you want to use?? [ Swift / ObjC ] > {ObjC} Would you like to include a demo application with your library? [ Yes / No ] > {Yes} Which testing frameworks will you use? [ Specta / Kiwi / None ] > {None} Would you like to do view based testing? [ Yes / No ] > {No} What is your class prefix? > {Prefix} security: SecKeychainSearchCopyNext: The specified item could not be found in the keychain. security: SecKeychainSearchCopyNext: The specified item could not be found in the keychain. security: SecKeychainSearchCopyNext: The specified item could not be found in the keychain. security: SecKeychainSearchCopyNext: The specified item could not be found in the keychain. security: SecKeychainSearchCopyNext: The specified item could not be found in the keychain. security: SecKeychainSearchCopyNext: The specified item could not be found in the keychain. Running pod install on your new library. Analyzing dependencies Fetching podspec for `YOURPODNAME` from `../` Downloading dependencies Installing YOURPODNAME (0.1.0) Generating Pods project Integrating client project [!] Please close any current Xcode sessions and use `YOURPODNAME.xcworkspace` for this project from now on. Sending stats Pod installation complete! There is 1 dependency from the Podfile and 1 total pod installed. Ace! you're ready to go! We will start you off by opening your project in Xcode open 'YOURPODNAME/Example/YOURPODNAME.xcworkspace' To learn more about the template see `https://github.com/CocoaPods/pod-template.git`. To learn more about creating a new pod, see `https://guides.cocoapods.org/making/making-a-cocoapod`. 编辑 YOURPODNAME.podspec Pod::Spec.new do |s| s.name = '{YOURPODNAME}' s.version = '0.1.0' s.summary = 'A short description of {YOURPODNAME}.' # This description is used to generate tags and improve search results. # * Think: What does it do? Why did you write it? What is the focus? # * Try to keep it short, snappy and to the point. # * Write the description between the DESC delimiters below. # * Finally, don't worry about the indent, CocoaPods strips it! s.description = 'MIT', :file => 'LICENSE' } s.author = { '{YOURNAME}' => '{YOURMAIL}' } s.source = { :git => 'https://github.com/{YOURGITHUBNAME}/{YOURPODNAME}.git', :tag => s.version.to_s } # s.social_media_url = 'https://twitter.com/' s.ios.deployment_target = '8.0' s.source_files = '{YOURPODNAME}/Classes/**/*' # s.resource_bundles = { # '{YOURPODNAME}' => ['{YOURPODNAME}/Assets/*.png'] # } # s.public_header_files = 'Pod/Classes/**/*.h' # s.frameworks = 'UIKit', 'MapKit' # s.dependency 'AFNetworking', '~> 2.3' end 必须要修改的:s.summary: pod 摘要s.description: pod 描述s.homepage: pod 在 github 中的地址s.author: 作者姓名及邮箱s.source: pod 的 git 地址 其余的根据您的实际情况进行修改，每个字段的描述，下篇文章中会详细介绍！ 验证 YOURPODNAME.podspec $ pod lib lint -> YOURPODNAME (0.1.0) - WARN | summary: The summary is not meaningful. - WARN | url: The URL (https://github.com/{YOURGITHUBNAME}/YOURPODNAME) is not reachable. - NOTE | xcodebuild: note: Using new build system - NOTE | [iOS] xcodebuild: note: Planning build - NOTE | [iOS] xcodebuild: note: Constructing build description - NOTE | xcodebuild: note: Execution policy exception registration failed and was skipped: Error Domain=NSPOSIXErrorDomain Code=1 \"Operation not permitted\" - NOTE | [iOS] xcodebuild: warning: Skipping code signing because the target does not have an Info.plist file and one is not being generated automatically. [!] YOURPODNAME did not pass validation, due to 2 warnings (but you can use `--allow-warnings` to ignore them). You can use the `--no-clean` option to inspect any issue. 虽然上面还有两个 WARN，但是已经符合官方的标准了，可以进行提交操作了。但是！如果您是完美主义者，可以彻底处理干净后在进行提交！（我解决了，您随意！） 提交代码 git add . git commit -m \"创建 pod 库\" git push 创建并提交 tag git tag -a 0.1.0 -m '创建 pod 库' git push origin --tags 注意： 此处的 tag 应与 .podspec 文件中的 s.version 保持一致。每次修改 pod 中的代码，添加 tag 后，都应同时修改 .podspec 文件中的 s.version 提交 pod $ pod trunk push [!] Found podspec `YOURPODNAME.podspec` Updating spec repo `master` Validating podspec -> YOURPODNAME (0.1.0) - NOTE | xcodebuild: note: Using new build system - NOTE | [iOS] xcodebuild: note: Planning build - NOTE | [iOS] xcodebuild: note: Constructing build description - NOTE | xcodebuild: note: Execution policy exception registration failed and was skipped: Error Domain=NSPOSIXErrorDomain Code=1 \"Operation not permitted\" - NOTE | [iOS] xcodebuild: warning: Skipping code signing because the target does not have an Info.plist file and one is not being generated automatically. Updating spec repo `master` -------------------------------------------------------------------------------- 🎉 Congrats 🚀 YOURPODNAME (0.1.0) successfully published 📅 June 18th, 10:30 🌎 https://cocoapods.org/pods/YOURPODNAME 👍 Tell your friends! -------------------------------------------------------------------------------- 恭喜您，您已经成功的将您创建的 pod 库推送到了官方 pod 库！ 坑点 & 解决方案 Failed to open TCP connection to trunk.cocoapods.org:443 (getaddrinfo: nodename nor servname provided, or not known) 解： 此问题常见于 pod trunk 相关的命令。网络大环境不行，要么呢啥（技术都懂的），要么连接手机开热点进行操作。 Unable to accept duplicate entry for: YOURPODNAME (0.1.0) 解： pod trunk push 时发生此错误，说明该 pod 库在远端已经有了 0.1.0 版本。解决方案有两个： 使用一个远端还没有的版本号 使用 pod trunk delete YOURPODNAME 0.1.0 删除远端的 0.1.0 版本，然后重新进行推送 unable to find a pod with name, author, summary, or description matching 'YOURPODNAME' 解： 信息更新不及时导致。 首先删除本地缓存 rm ~/Library/Caches/CocoaPods/search_index.json 然后执行: pod update Title: 如何创建一个公有 Pod 库 Date: 2019.06.21 Author: zhangpeng Github: https://github.com/fullstack-zhangpeng Copyright © zhang peng 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-07-22 10:44:14 "},"ios/sandbox.html":{"url":"ios/sandbox.html","title":"App 沙盒","keywords":"","body":"App 沙盒 从 iOS8 以后，每次App重新运行后，沙盒路径都会变化。 Documents 目录 保存应用运行时生成的需要持久化的数据，iTunes 会自动备份该目录。苹果建议将程序中建立的或在程序中浏览到的文件数据保存在该目录下，iTunes 备份和恢复的时候会包括此目录。 NSString *path = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject]; Library 目录 存储程序的默认设置和其他状态信息，iTunes 会自动备份该目录（仅Preferences）。 NSString *path = [NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES) firstObject]; 这个目录下有两个子目录：Caches 和 Preferences Preferences 保存应用的所有偏好设置，iOS 的 Settings（设置）应用会在该目录中查找应用的设置信息，iTunes 会自动备份该目录。 Caches 存放缓存文件，iTunes 不会备份此目录，此目录下文件不会在应用退出删除。一般存放体积比较大，不是特别重要的资源。 NSString *path = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) firstObject]; Tmp 目录 保存应用运行时所需的临时数据，使用完毕后再将相应的文件从该目录删除。应用没有运行时，系统也有可能会清除该目录下的文件，iTunes 不会同步该目录。设备重启时，该目录下的文件会丢失。 NSString *path = NSTemporaryDirectory(); Title: App 沙盒 Date: 2019.04.15 Author: zhangpeng Github: https://github.com/fullstack-zhangpeng Copyright © zhang peng 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-07-22 10:44:14 "},"ios/block-statement.html":{"url":"ios/block-statement.html","title":"Block 的声明方式","keywords":"","body":"Block 的声明方式 原文链接：How Do I Declare A Block in Objective-C? 局部变量 returnType (^blockName)(parameterTypes) = ^returnType(parameters) {...}; 属性 @property (nonatomic, copy, nullability) returnType (^blockName)(parameterTypes); 方法参数 - (void)someMethodThatTakesABlock:(returnType (^nullability)(parameterTypes))blockName; 方法调用的参数 [someObject someMethodThatTakesABlock:^returnType (parameters) {...}]; C函数的参数 void SomeFunctionThatTakesABlock(returnType (^blockName)(parameterTypes)); 类型定义 typedef returnType (^TypeName)(parameterTypes); TypeName blockName = ^returnType(parameters) {...}; Title: Block 的声明方式 Date: 2019.03.10 Author: zhangpeng Github: https://github.com/fullstack-zhangpeng Copyright © zhang peng 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-07-22 10:44:14 "},"ios/rac-eventbus-rxjava.html":{"url":"ios/rac-eventbus-rxjava.html","title":"Rac EventBus RxJava","keywords":"","body":"Rac EventBus RxJava Rac 是什么 Rac 全称 Reactivecocoa，是一个应用于 iOS 和 OS X 开发的框架，它的灵感来自函数式 响应式编程。 Rac 做了什么 将原有的各种设计模式，包括 中心以及观察者模式各种『输入』，都抽象成了信号，通过信号的传递来处理这些行为。简化了事件的传递，每个部分只需要关注信号的传递及状态即可。最终将信号通过不同的组合，达成我们最终的目的。 Rac 的组成 1. 核心组件 信号源 RACStream 及其子类； 订阅者 RACSubscriber及其子类 调度器 RACScheduler及其子类 清洁工 RACDisposable及其子类 2. 组件间的关系 订阅者订阅信号源后，调度器保证信号源的传递及顺序 信号到达后，根据信号的状态，进行不同的操作 操作完成后，通过清洁工清理掉信号源 Rac 的用处 处理异步或者事件驱动数据源 连接依赖的操作 并行地独立地工作 简化集合转换 Rac 的使用 Rac 的简单使用 对比 EventBus RxJava EventBus EventBus是一款针对Android设计的发布/订阅事件总线，使用订阅/发布模式让组件间的通信变得简单。主要功能是替代Intent，Handler，BroadCast在Fragment，Activity，Service，线程之间的消息传递。 EventBus 四大组成部分： Publisher发布者 用于分发我们的Event事件，在EventBus中通过post方法进行分发传送。 Subscriber订阅者 用于接受我们的事件，我们在订阅事件中处理我们接收的数据。 Event事件 任何一个对象都可以作为事件，比如任何字符串，事件是发布者和订阅者之间的通信载体。 EventBus 类似于中转站，将我们的事件进行对应的分发处理。 优点 简化了组件之间的通信 将事件发送者和接收者分离 在Activities，Fragments和background threads中表现良好 避免复杂且容易出错的依赖关系和生命周期问题 使代码更简单 性能开销小 代码量小（约50k左右） 缺点 消息乱飞？不方便 Debug？ 使用 定义一个事件 public static class MessageEvent { /* Additional fields if needed */ } 声明一个用于响应的方法，并且在适当的生命周期注册或注销 @Subscribe(threadMode = ThreadMode.MAIN) public void onMessageEvent(MessageEvent event) { /* Do something */ } @Override public void onStart() { super.onStart(); // 通过 isRegistered 检查是否已经注册订阅 if (!EventBus.getDefault().isRegistered(this)) { EventBus.getDefault().register(this); } } @Override public void onStop() { super.onStop(); EventBus.getDefault().unregister(this); } 根据不同的应用场景，可以选择在不同的声明周期注册或移除订阅 @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); } @Override protected void onDestroy() { super.onDestroy(); } @Override protected void onResume() { super.onResume(); } @Override protected void onPause() { super.onPause(); } 发布事件，事件发布后，订阅者中的响应方法就会受到事件 EventBus.getDefault().post(new MessageEvent()); RxJava RxJava 在 GitHub 主页上的自我介绍是\"a library for composing asynchronous and event-based programs using observable sequences for the Java VM\"（一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库），核心可以总结为两个字：异步。说到根上，它就是一个实现异步操作的库。而它的异步实现，是通过一种扩展的观察者模式来实现的。 RxJava 的四个基本概念 Observable (可观察者，即被观察者) 决定什么时候触发事件以及触发怎样的事件。 Observer (观察者) 决定事件触发的时候将有怎样的行为。 subscribe (订阅) 创建了 Observable 和 Observer 之后，再用 subscribe() 方法将它们联结起来，整条链子就可以工作了 事件 使用 Observable.from(folders) .flatMap(new Func1>() { @Override public Observable call(File file) { return Observable.from(file.listFiles()); } }) .filter(new Func1() { @Override public Boolean call(File file) { return file.getName().endsWith(\".png\"); } }) .map(new Func1() { @Override public Bitmap call(File file) { return getBitmapFromFile(file); } }) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Action1() { @Override public void call(Bitmap bitmap) { imageCollectorView.addImage(bitmap); } }); 附 Reactivecocoa ReactiveCocoa 常用API整理 EventBus EventBus 中文文档 给 Android 开发者的 RxJava 详解 RxJava的使用 RxJava的使用（一）基本用法 RxJava的使用（二）Action RxJava的使用（三）转换——map、flatMap Title: 聊一聊 Rac Date: 2018.12.08 Author: zhangpeng Github: https://github.com/fullstack-zhangpeng Copyright © zhang peng 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-07-22 10:44:14 "},"ios/dynamic-icon.html":{"url":"ios/dynamic-icon.html","title":"动态更换 App 图标","keywords":"","body":"动态更换 App 图标 在iOS 10.3苹果添加了更换图标的功能，通过这个功能，我们可以在适当的时候采取特定的方式为我们的App更换图标。 听似很好很方便，实则并没有。原因如下： 更换的图标，我们需要预置在项目中 替换图标这个功能，一定要经过用户同意（虽然有跳过这一步的方法，但是不建议使用） 虽然我们在使用这个功能时有着种种限制，但是瑕不掩瑜，他同样为我们的用户体验带来了提升： 逢年过节想换个应景的App图标，不用在进行发版了 公司有个重大活动需要更换图标，不用担心活动前不能成功发版上线了 注： 我们更换的不只是APP的图标，还有通知栏的中的图标，以及设置界面中的图标等所有与我们 App 有关的图标。 准备你要更换的图标 将我们需要更换的图标放到我们的项目目录中（因为放到.xcassets中不管用），图片的命名建议以下面的方式命名，例如：xx20x20@2x.png，xx20x20@3x.png…这样在填写Info.plist时也会省事很多。 PS： 其实对于更换的图标，我们也可以只提供一张，但命名时，我们就不要填写具体的尺寸了，只保留图片名字即可，例如：xx@2x.png，xx@3x.png， 但是效果上可能不如准备一整套的效果好。毕竟把一张桌面图标大小的图片塞到通知图标那么小的框里，图片会压缩。 修改Info.plist 想要实现换图标的功能，Info.plist 文件的修改是很重要的一步。 CFBundleIcons: 一个字典，包含所有AppIcon信息，即上图的Icon files(iOS 5) CFBundlePrimaryIcon: 如果已经在Assets.xcassets中设置了AppIcon，那么CFBundlePrimaryIcon中的配置会被忽略，Assets.xcassets的AppIcon将会自动配置到CFBundlePrimaryIcon中。 CFBundleAlternateIcons: 一个数组，负责配置可供替换的icon信息 UIPrerenderedIcon: 是否已经预渲染，如果不设置该项或者设为NO。系统会自动为icon进行渲染增加光泽 如果想详细了解CFBundleIcons, CFBundlePrimaryIcon, CFBundleAlternateIcons，请查看附件2 如果iPad需要也需要更换图标，那么我们需要在CFBundleIcons~ipad进行同样的设置。 注： 不能把图片放在.xcassets里面 编写代码 通过查看文档，我们可以看到下面几个属性和方法。 // If false, alternate icons are not supported for the current process. // 检查是否支持更换图标 @property (readonly, nonatomic) BOOL supportsAlternateIcons NS_EXTENSION_UNAVAILABLE(\"Extensions may not have alternate icons\") API_AVAILABLE(ios(10.3), tvos(10.2)); // Pass `nil` to use the primary application icon. The completion handler will be invoked asynchronously on an arbitrary background queue; be sure to dispatch back to the main queue before doing any further UI work. // 更换图标 - (void)setAlternateIconName:(nullable NSString *)alternateIconName completionHandler:(nullable void (^)(NSError *_Nullable error))completionHandler NS_EXTENSION_UNAVAILABLE(\"Extensions may not have alternate icons\") API_AVAILABLE(ios(10.3), tvos(10.2)); // If `nil`, the primary application icon is being used. // 当前图标的名称 @property (nullable, readonly, nonatomic) NSString *alternateIconName NS_EXTENSION_UNAVAILABLE(\"Extensions may not have alternate icons\") API_AVAILABLE(ios(10.3), tvos(10.2)); 系统提供的 API 简单明了，唯一要注意的是下面这个方法。 - (void)setAlternateIconName:(nullable NSString *)alternateIconName completionHandler:(nullable void (^)(NSError *_Nullable error))completionHandler 方法中的alternateIconName参数，是要填写您在Info.plist 中填写的名字，如图二中所示，我们应当在此方法中填写female或者male1. 代码示例 为了方便大家使用，我将更换图标相关的代码已经写好在下面，如需自取。 也可以访问 DynamicAppIconDemo，查看 FSAppIconManager 类 + (NSString *)getCurrentAppIconName { if (@available(iOS 10.3, *)) { return ([UIApplication sharedApplication].alternateIconName.length == 0) ? @\"\" : [UIApplication sharedApplication].alternateIconName; } else { // Fallback on earlier versions return @\"\"; } } + (BOOL)canChangeAppIcon { if (@available(iOS 10.3, *)) { return [[UIApplication sharedApplication] supportsAlternateIcons]; } else { // Fallback on earlier versions return NO; } } + (void)changeAppIconWithIconName:(NSString *)iconName completionHandler:(void (^)(NSError * _Nullable))completionHandler { if (@available(iOS 10.3, *)) { [[UIApplication sharedApplication] setAlternateIconName:iconName completionHandler:^(NSError * _Nullable error) { if (!error) { completionHandler(nil); } else { completionHandler(error); } }]; } else { // Fallback on earlier versions NSDictionary *userInfo = @{ NSLocalizedDescriptionKey: NSLocalizedString(@\"AppIcon change failed\", nil), NSLocalizedFailureReasonErrorKey: NSLocalizedString(@\"The current system version does not support replacing the AppIcon.\", nil), NSLocalizedRecoverySuggestionErrorKey: NSLocalizedString(@\"\", nil) }; NSError *error = [NSError errorWithDomain:@\"\" code:34001 userInfo:userInfo]; completionHandler(error); } } 下面给出部分 App Icon 相关的资料 App Icon Attributes Attribute Value Format PNG Color space sRGB or P3 (see Color Management) Layers Flattened with no transparency Resolution Varies. See Image Size and Resolution Shape Square with no rounded corners App Icon Sizes Device or context Icon size iPhone 180px × 180px (60pt × 60pt @3x) 120px × 120px (60pt × 60pt @2x) iPad Pro 167px × 167px (83.5pt × 83.5pt @2x) iPad, iPad mini 152px × 152px (76pt × 76pt @2x) App Store 1024px × 1024px (1024pt × 1024pt @1x) Spotlight, Settings, and Notification Icons Device or context Spotlight icon size Settings icon size Notification icon size iPhone 120px × 120px (40pt × 40pt @3x) 87px × 87px (29pt × 29pt @3x) 60px × 60px (20pt × 20pt @3x) 80px × 80px (40pt × 40pt @2x) 58px × 58px (29pt × 29pt @2x) 40px × 40px (20pt × 20pt @2x) iPad Pro, iPad, iPad mini 80px × 80px (40pt × 40pt @2x) 58px × 58px (29pt × 29pt @2x) 40px × 40px (20pt × 20pt @2x) Notice Don’t add an overlay or border to your Settings icon. iOS automatically adds a 1-pixel stroke to all icons so that they look good on the white background of Settings. 附 Human Interface Guidelines - App Icon CFBundleIcons,CFBundlePrimaryIcon,CFBundleAlternateIcons Title: 动态更换 App 图标 Date: 2018.07.10 Author: zhangpeng Github: https://github.com/fullstack-zhangpeng Copyright © zhang peng 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-07-22 10:44:14 "},"ios/sirikit.html":{"url":"ios/sirikit.html","title":"SiriKit 人机界面指南","keywords":"","body":"SiriKit 人机界面指南 本文为译文，原文连接：Human Interface Guidelines-Siri 你的应用可以通过集成Siri，以响应用户的语音命令和问题，完成某些任务。Siri对语言进行处理并进行语义分析，将这些语音指令转换成应用程序可以处理的指令。应用程序定义它支持的任务，验证收到的信息，提供Siri提供信息，执行操作。应用程序的响应由 Siri 反馈，并且呈现在 Siri 界面中。如果可以的话，你的应用程序可以为Siri提供一个定制的用户界面来展示。例如，健身应用可能会提供定制的健身信息。 争取一种不需要触摸或是查看屏幕的语音操作体验。 人们可以通过耳机，汽车或是在房间的另一头与Siri互动。尽可能地让用户在不解锁手机的情况下完成任务。 不要试图模仿或操纵Siri。 你的应用程序永远不应该模仿Siri，试图复制Siri提供的功能，或者提供看上去来自苹果的响应。 适当的内容。 绝不要包含可能冒犯或侮辱的内容。 不做广告。 你的应用程序的Siri体验不应该包括广告、营销或应用内购买销售推销。 支持的交互 提供以下服务的iOS应用程序可以与Siri集成。 服务 支持的交互 音视频通话 拨打电话搜索通话记录 CarPlay集成 激活并保存司机的设置。切换汽车的音乐。改变汽车的空调设置。改变汽车的除霜设置。改变汽车的座位设置。切换汽车的收音机频道。 健身活动 开始、暂停、恢复、结束、取消训练。 待办的事和笔记 创建待办事项列表和项目。搜索待办事项列表和项目。将待办事项列表项标记为完成。根据日期、时间和/或位置创建提醒。创建笔记。搜索笔记。修改笔记。 信息 发送消息。读取接收到的消息。搜索信息。 支付 发起付款。请求支付。支付账单。寻找账单。搜索并查看账户信息，包括余额、点数和英里数。账户之间的转账。 相片管理 搜索照片并在应用中显示。 出行预定 出行预定。出行信息查询。 汽车集成 启动危险信号灯或按喇叭。打开关闭车门。检查当前的燃料或功率。 显示条码 显示一个条码，比如二维码或条形码。 给使用者的反馈 快速响应，减少交互。 人们使用Siri是为了方便，并希望得到快速响应。提出有效的、有重点的选择，减少额外提示的可能性。 让人们直接了解内容。 从Siri到应用程序的转换应该直接完成预期的目的。不要显示中间的屏幕或信息来降低体验。 相关的和准确的。 使你的应用程序的响应与用户当前的请求和期望相关。例如，如果用户要求Siri用你的应用发送一条消息，发送一条消息。不要做不同的动作。 当请求与财务相关时，默认使用最安全、花费最少的的选项。 绝不要欺骗用户或歪曲信息。当购物时有多个价格时，不要默认为最昂贵的。当用户正在付款时，不要在没有通知他们的情况下收取额外费用。 设计一个自定义界面 确保你的界面与Siri很好地融合在一起。 使用你的应用程序的颜色、图像和其他设计元素来传达你的品牌是很好的，但任何界面元素都应该让人感觉它们属于Siri。除非你的应用需要一个完全定制的界面，否则请将你的内容集成到Siri提供的默认界面中。 提供足够的间距和边距。 避免将内容扩展到界面的边缘，除非它的内容看起来像地图一样自然地流出屏幕。通常，在界面的每条边和内容之间提供至少几个像素的空白。使用界面顶部的app图标进行对齐指导。当与此图标的中心对齐时，内容往往会显示得很好。 最小化界面的高度。 理想情况下，您的界面不应该高于屏幕的高度，这样用户就可以在不滚动的情况下看到所有内容。 不要创建一个具有交互性的界面。 你的界面不能对手势做出反应——除了会打开你的应用程序的点击——或者在Siri中显示其他事件，所以要避免显示互动的图像或形状。 不要在你的界面中包含你的应用程序名称或图标。 系统自动显示这些信息。 提高准确性 如果可以的话，定义自定义词汇表。 通过定义人们可能在请求中实际使用的特定术语，如账户名、联系人姓名、照片标签、相册名称、乘车选项和健身名称，帮助Siri了解你的应用程序执行的更多操作。这些术语应该是非通用的，并且是你的应用程序独有的。不要包括其他应用程序名称、明显与其他应用程序相关的术语、不恰当的语言或保留的短语，比如“嘿，Siri”。请注意，你定义的任何术语都是Siri用来帮助解决请求的，但不能保证被识别。 考虑定义备用的应用程序名称。 如果人们对你的应用程序名字的发音有所不同，你可以提供一个可供选择的名字列表，以增加你用Siri定位应用程序时的灵活性。例如，一个UnicornChat应用程序可能会将术语Unicorn定义为另一个应用程序名称。不要将其他应用程序名称作为你应用程序的替代名称。 提供请求示例。 提供一些用于展示在 Siri 帮助界面中的事例短语。用这些短语来教人们用你的应用程序使用Siri的最简单、最有效的方法。 附 SiriKit Human Interface Guidelines-Siri Title: SiriKit 人机界面指南 Date: 2018.07.03 Author: zhangpeng Github: https://github.com/fullstack-zhangpeng Copyright © zhang peng 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-07-22 10:44:14 "},"ios/gcd.html":{"url":"ios/gcd.html","title":"GCD 同步异步与串行并行","keywords":"","body":"GCD 同步异步与串行并行 不论是同步异步，还是串行并行，单独讲一个，意义都不大。在实际开发中，只有将他们进行各式各样的组合，才能更好地完成我们的需求，本篇文章中就会对他们之间的组合进行举例~ 名词解释 在学习之前，我们需要先了解一些基础知识： 线程： 程序执行任务的最小调度单位 任务： 我们要完成的工作，可以是一个方法也可以是一个block 队列： 用于保存“任务”的数组 同步执行： 不能开启新线程，任务创建后，必须执行完才可以继续后面的操作 异步执行： 可以开启新线程，任务创建后，可以继续执行后面的操作，不必等待任务完成 串行队列： 底层只维护一个线程，队列中的任务只能串行按顺序执行 并行队列： 底层使用线程池维护多个线程，队列中的任务可以并发执行 实践出真知 当同步异步遇上串行并行会发生什么呢？让我们拭目以待～ 同步执行 + 串行队列 不会开启新线程，所有的任务都在主线程中执行。因为串行队列的原因，任务会按顺序执行。 dispatch_queue_t queue = dispatch_queue_create(\"blog.zhangpeng.site\", DISPATCH_QUEUE_SERIAL); NSLog(@\"---start---%@\", [NSThread currentThread]); dispatch_sync(queue, ^{ sleep(5); NSLog(@\"任务1---%@\", [NSThread currentThread]); }); dispatch_sync(queue, ^{ sleep(3); NSLog(@\"任务2---%@\", [NSThread currentThread]); }); dispatch_sync(queue, ^{ sleep(1); NSLog(@\"任务3---%@\", [NSThread currentThread]); }); NSLog(@\"---end---%@\", [NSThread currentThread]); /** 控制台输出： ---start---{number = 1, name = main} 任务1---{number = 1, name = main} 任务2---{number = 1, name = main} 任务3---{number = 1, name = main} ---end---{number = 1, name = main} */ 同步执行 + 并行队列 虽然是并行队列，但是因为是同步执行，所以不会开启新线程。因为没有开启新线程，所以所有任务都在主线程执行，所以即使是并行队列，任务也需要按顺序依次执行。 dispatch_queue_t queue = dispatch_queue_create(\"blog.zhangpeng.site\", DISPATCH_QUEUE_CONCURRENT); NSLog(@\"---start---%@\", [NSThread currentThread]); //使用同步函数封装三个任务 dispatch_sync(queue, ^{ sleep(5); NSLog(@\"任务1---%@\", [NSThread currentThread]); }); dispatch_sync(queue, ^{ sleep(3); NSLog(@\"任务2---%@\", [NSThread currentThread]); }); dispatch_sync(queue, ^{ sleep(1); NSLog(@\"任务3---%@\", [NSThread currentThread]); }); NSLog(@\"---end---%@\", [NSThread currentThread]); /** ---start---{number = 1, name = main} 任务1---{number = 1, name = main} 任务2---{number = 1, name = main} 任务3---{number = 1, name = main} ---end---{number = 1, name = main} */ 异步执行 + 串行队列 因为是异步执行，所以开启了新的线程，因为是串行队列，所以任务在新的线程中按顺序执行。 dispatch_queue_t queue = dispatch_queue_create(\"blog.zhangpeng.site\", DISPATCH_QUEUE_SERIAL); NSLog(@\"---start---%@\", [NSThread currentThread]); dispatch_async(queue, ^{ sleep(5); NSLog(@\"任务1---%@\", [NSThread currentThread]); }); dispatch_async(queue, ^{ sleep(3); NSLog(@\"任务2---%@\", [NSThread currentThread]); }); dispatch_async(queue, ^{ sleep(1); NSLog(@\"任务3---%@\", [NSThread currentThread]); }); NSLog(@\"---end---%@\", [NSThread currentThread]); /** ---start---{number = 1, name = main} ---end---{number = 1, name = main} 任务1---{number = 3, name = (null)} 任务2---{number = 3, name = (null)} 任务3---{number = 3, name = (null)} */ 异步执行 + 并行队列 因为是异步执行，所以开启了新的线程，因为是并行队列，所以任务可以不按顺序执行。因此在这种组合模式下，可以开启多条线程。 dispatch_queue_t queue = dispatch_queue_create(\"blog.zhangpeng.site\", DISPATCH_QUEUE_CONCURRENT); NSLog(@\"---start---%@\", [NSThread currentThread]); dispatch_async(queue, ^{ sleep(5); NSLog(@\"任务1---%@\", [NSThread currentThread]); }); dispatch_async(queue, ^{ sleep(3); NSLog(@\"任务2---%@\", [NSThread currentThread]); }); dispatch_async(queue, ^{ sleep(1); NSLog(@\"任务3---%@\", [NSThread currentThread]); }); NSLog(@\"---end---%@\", [NSThread currentThread]); /** ---start---{number = 1, name = main} ---end---{number = 1, name = main} 任务3---{number = 3, name = (null)} 任务2---{number = 4, name = (null)} 任务1---{number = 5, name = (null)} */ 同步执行 + 主队列 死锁。任务1需要等待主队列中所有的任务都执行完毕才可以执行，但是因为是同步执行，要执行完任务1才能执行主队列中的其他任务，最后互相等待，造成了死锁。这边其实与任务2和任务3并没有什么关系。QAQ，不知道为什么其他人的博客都说和任务2和3有关。 dispatch_queue_t queue = dispatch_get_main_queue(); NSLog(@\"---start---%@\", [NSThread currentThread]); dispatch_sync(queue, ^{ sleep(5); NSLog(@\"任务1---%@\", [NSThread currentThread]); }); dispatch_sync(queue, ^{ sleep(3); NSLog(@\"任务2---%@\", [NSThread currentThread]); }); dispatch_sync(queue, ^{ sleep(1); NSLog(@\"任务3---%@\", [NSThread currentThread]); }); NSLog(@\"---end---%@\", [NSThread currentThread]); /** ---start---{number = 1, name = main} */ 异步执行 + 主队列 虽然是异步执行，但是主队列中的任务是在主线程中执行，因此没有开启新的线程执行任务，任务按顺序执行。 dispatch_queue_t queue = dispatch_get_main_queue(); NSLog(@\"---start---%@\", [NSThread currentThread]); dispatch_async(queue, ^{ sleep(5); NSLog(@\"任务1---%@\", [NSThread currentThread]); }); dispatch_async(queue, ^{ sleep(3); NSLog(@\"任务2---%@\", [NSThread currentThread]); }); dispatch_async(queue, ^{ sleep(1); NSLog(@\"任务3---%@\", [NSThread currentThread]); }); NSLog(@\"---end---%@\", [NSThread currentThread]); /** ---start---{number = 1, name = main} ---end---{number = 1, name = main} 任务1---{number = 1, name = main} 任务2---{number = 1, name = main} 任务3---{number = 1, name = main} */ 结 上面简单的对同步异步执行与串行并行队列的几种组合方式进行了举例，而我们的日常工作中要比上述举例复杂的多，但是本质还是不变的，我们一定可以找到一种合理的组合方式解决我们遇上的问题的。 Title: GCD 同步异步与串行并行 Date: 2018.05.29 Author: zhangpeng Github: https://github.com/fullstack-zhangpeng Copyright © zhang peng 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-07-22 10:44:14 "},"ios/cocoapods.html":{"url":"ios/cocoapods.html","title":"CocoaPods 安装及错误处理","keywords":"","body":"CocoaPods 安装及错误处理 安装 Ruby 环境 安装 CocoaPods 需要 ruby 环境，因此我们需要先安装 ruby 环境。Mac 一般都已经装好了 ruby 环境。如果不确定，我们可以通过 ruby -v 检查是否拥有 ruby 环境。 $ ruby -v ruby 2.3.3p222 (2016-11-21 revision 56859) [universal.x86_64-darwin17] 上面显示的内容，表示着我们已经安装了ruby。 安装 cocoapods 安装 cocoapods 简单只需要执行下面的代码即可。 // 安装 cocoapods $ sudo gem install cocoapods 提高访问速度 绝大多数人在执行安装 cocoapods 后，会发现半天没有反应，没错，你猜的没错，正是因为那堵至高无上的墙~ 因此我们通过下面的方式换个ruby源： // 移除现有sources $ gem sources --remove https://rubygems.org/ // 添加ruby-china sources $ gem sources --add https://gems.ruby-china.com/ // 检查ruby源是否更换成功 $ gem sources -l *** CURRENT SOURCES *** https://gems.ruby-china.com/ 当终端显示出上面的 https://gems.ruby-china.com/，代表我们操作成功。 常见坑点 依赖的 Ruby 环境版本过低 ERROR:While executing gem ... (Gem::DependencyError) Unable to resolve dependencies: cocoapods requires cocoapods-core (= 1.2.0), cocoapods-downloader (= 1.1.3), cocoapods-trunk (= 1.1.2), molinillo (~> 0.5.5), xcodeproj (= 1.4.1); activesupport requires thread_safe (>= 0.3.4, ~> 0.3); tzinfo requires thread_safe (~> 0.1) 更新 Ruby 环境即可 // 更新 gem版本 $ sudo gem update --system 当你看到RubyGems system software updated，意味着环境成功更新 没有权限安装 cocoapods 苹果系统升级OS X EL Capitan后，使用sudo gem install cocoapods安装时，会发生下面错误 ERROR:While executing gem ... (Errno::EPERM) Operation not permitted - /usr/bin/xcodeproj 使用下面的代码进行安装 sudo gem install -n /usr/local/bin cocoapods pod setup 耗时太久，不知道进度 界面长时间卡在Creating search index for spec repo 'master'..过程，可以通过下面代码查看进度： du-sh ~/.cocoaPods 搜索 pod 库失败 搜索类库失败时可以尝试通过下面的命令删除本地缓存 rm ~/Library/Caches/CocoaPods/search_index.json Title: CocoaPods 安装及错误处理 Date: 2018.05.24 Author: zhangpeng Github: https://github.com/fullstack-zhangpeng Copyright © zhang peng 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-07-22 10:44:14 "},"ios/message-forwarding.html":{"url":"ios/message-forwarding.html","title":"iOS 消息转发机制","keywords":"","body":"iOS 消息转发机制 当对象接收到无法解读的消息（unrecognized selector sent to instance 0x87），就会启动消息转发机制，由程序员指定处理方法。 消息转发两大阶段 动态方法解析检查当前接收者能否动态添加方法，处理这个unrecognized selector。 完整的消息转发第一阶段执行完毕后，如接收者不能以动态新增方法处理这个unrecognized selector，接下来，会分两种情况： 有备援接收者（replacement receiver）在运行期将消息转给备援接收者，由备援接收者完成消息的处理。 无备援接收者（replacement receiver） 启动一套“完整的消息转发机制”，将消息封装到NSInvocation对象中，交给接收者处理。 动态方法解析 如果没有找到需要执行的方法，会根据方法的类型，执行不同的处理方法。 处理无法调用的类方法 + (BOOL)resolveClassMethod:(SEL)sel; 处理无法调用的实例方法 + (BOOL)resolveInstanceMethod:(SEL)sel; 一般是提前写好相关的实现代码，通过 Runtime 在此处插入到类中。 e.g. /** 没有找到SEL的实现时会执行下方的方法 @param sel 当前对象调用并且找不到IML的SEL @return 是否可以处理这个方法，并返回yes */ + (BOOL)resolveInstanceMethod:(SEL)sel { // 当返回YES时 // 在这里通过Runtime在将已经写好实现的代码插入到类中。 // ... return YES; // 当返回NO时 // 会接着执行forwordingTargetForSelector:方法 // return NO; } 消息转发 有备援接收者 在方法 - (id)forwardingTargetForSelector:(SEL)aSelector 中返回可以处理该消息的对象，交由该对象去处理这个消息。如果此处返回nil，则表示没有其他对象可以处理这个消息，然后通过完整的消息转发机制来处理。 /** 将当前对象不存在的SEL传给其他存在该SEL的对象 @param aSelector 当前类中不存在的SEL @return 存在该SEL的对象 */ - (id)forwardingTargetForSelector:(SEL)aSelector { // 不传递给其他对象 // 将会执行- (void)forwardInvocation:(NSInvocation *)anInvocation; return nil; // 传递给一个其他对象，处理这个方法。 // 可以做相应的错误处理等 // 让OtherClass中相应的SEL去执行该方法 // return [[OtherClass alloc] init]; } 无备援接收者 如果接收者不能处理消息，并且没有备援接收者，最终只能采取一个完整的消息转发来处理消息。 通过NSInvocation包装方法的目标、参数等，然后通过 - (void)forwardInvocation:(NSInvocation *)invocation 将消息指派给目标对象。 - (void)forwardInvocation:(NSInvocation *)invocation { SecondClass * forwardClass = [SecondClass new]; SEL sel = invocation.selector; if ([forwardClass respondsToSelector:sel]) { [invocation invokeWithTarget:forwardClass]; } else { [self doesNotRecognizeSelector:sel]; } } Title: iOS 消息转发机制 Date: 2018.04.02 Author: zhangpeng Github: https://github.com/fullstack-zhangpeng Copyright © zhang peng 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-07-22 10:44:14 "},"ios/nsmethodsignature-nsinvocation.html":{"url":"ios/nsmethodsignature-nsinvocation.html","title":"NSMethodSignature 和 NSInvocation","keywords":"","body":"利用 NSMethodSignature 和 NSInvocation 实现方法调用 常见的调用方法的两种方式 performSelector: withObject: 优点： 可以调用运行时添加方法 缺点： 在编译阶段不会做校验。只有在程序运行的时候，才会知道是否存在即将调用的方法，如果方法不存在，程序会崩溃。因此为了保证程序的健壮，在调用方法前应该使用 - (BOOL)respondsToSelector:(SEL)aSelector，检查方法是否实现。 直接调用方法优点： 在编译阶段就会教研方法是否存在，Xcode会有相应提示缺点： 局限性大，如果想调用某个方法，必须先实现这个方法，不如 performSelector: withObject: 灵活。 升级版 使用 NSMethodSignature 和 NSInvocation 组合实现方法的调用。 NSMethodSignature 通过 NSMethodSignature 可以获取方法的参数类型和返回值类型。常用方法有： //从实例中获取实例方法签名，或者从类中获取类方法签名 + (NSMethodSignature *)instanceMethodSignatureForSelector:(SEL)aSelector //从一个类中获取实例方法签名 - (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector 可以通过下面的代码，更好的理解该怎么获取方法签名： SEL initSEL = @selector(init); SEL allocSEL = @selector(alloc); // 从NSString类中获取实例方法(init)的方法签名 NSMethodSignature *initSig = [NSString instanceMethodSignatureForSelector:initSEL]; // 从test实例中获取实例方法(init)的方法签名 initSig = [@\"test\" methodSignatureForSelector:initSEL]; // 从NSString类中获取类方法签名 NSMethodSignature *allocSig = [NSString methodSignatureForSelector:allocSEL]; NSInvocation NSInvocation 可以说是 performSelector: withObject: 的升级版，可以调用较为复杂的方法，进行参数、返回值的处理等; NSMethodSignature 和 NSInvocation 搭配的使用方法 NSString *str = @\"Test\"; str = [str stringByAppendingString:@\" AppendingString\"]; NSLog(@\"str: %@\", str); //需要调用的方法 SEL selector = @selector(stringByAppendingString:); //获取方法签名 NSMethodSignature *signature = [str methodSignatureForSelector:selector]; //创建 NSInvocation 对象 NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:signature]; //设置消息接受对象 invocation.target = str; //设置发送的消息 invocation.selector = selector; //建议通过signature.numberOfArgument获取参数个数 //可以保证不多参，不少参 //这边减2的原因是： //0位置的参数是 目标（self） //1位置的参数是 selector（_cmd） //所以2位置才是所需要的第一个参数 NSInteger paramCount = signature.numberOfArguments - 2; NSLog(@\"paramCount: %@\", @(paramCount)); for (int i = 0; i Title: 利用 NSMethodSignature 和 NSInvocation 实现方法调用 Date: 2018.03.10 Author: zhangpeng Github: https://github.com/fullstack-zhangpeng Copyright © zhang peng 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-07-22 10:44:14 "},"ios/build-failed.html":{"url":"ios/build-failed.html","title":"常见的编译失败","keywords":"","body":"常见的编译失败 -fobjv-weak is not supported on the current deloyment target 解决方案：更新 xcodeproj 版本。 通过终端进到项目目录 查看 xcodeproj 版本 gem list xcodeproj 安装 xcodeproj 最新版本 可以在 rubygems.org查看到最新的版本，目前应该是1.5.6。 gem install xcodeproj -v 1.5.6 再次查看 xcodeproj 版本 gem list xcodeproj 卸载旧版本的 xcodeproj gem uninstall xcodeproj -v 1.5.6 按下 command + b，你会发现已经可以成功编译了！ Title: 常见的编译失败 Date: 2018.02.09 Author: zhangpeng Github: https://github.com/fullstack-zhangpeng Copyright © zhang peng 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-07-22 10:44:14 "},"ios/hook-system-delegate-method.html":{"url":"ios/hook-system-delegate-method.html","title":"Hook 系统代理方法","keywords":"","body":"Hook 系统代理方法 本篇文章主要叙述的是通过 Runtime 相关知识，完成对 UIScrollView 的代理方法进行 hook。从而添加一个停止滚动的回调。 Runtime 做 iOS 开发的同学们一定知道 Runtime ，这里就不讲太多了。这个是 Runtime 文档，有兴趣的同学，可以自己查阅一下。网上关于 Runtime 的博客也有很多，官方文档看不懂，可以看看其他人的博客。(๑•̀ㅂ•́)و UIScrollView 停止滚动的类型 通过调查发现 UIScrollView 停止滚动的类型分为三种： 快速滚动，自然停止 快速滚动，手指按压突然停止 慢速上下滑动停止 第1种类型，比较简单，在 UIScrollView 的代理中就可以监听到。 - (void)scrollViewWillBeginDecelerating:(UIScrollView *)scrollView; 而第2种类型和第3种类型，就没有方法让我们可以直接监听到了。但是只要是滑动了，就一定会触发 UIScrollView 的下面代理，然后通过 UIScrollView 部分属性的改变，我们就可以监听到滚动停止了，后面会详细介绍方法。 - (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView; - (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate; 添加 UIScrollView 滚动停止回调 监听 UIScrollView 停止滚动 通过翻阅文档，我们可以看到 UIScrollView 有三个属性: tracking、dragging、decelerating。 // returns YES if user has touched. may not yet have started dragging @property(nonatomic,readonly,getter=isTracking) BOOL tracking; // returns YES if user has started scrolling. this may require some time and or distance to move to initiate dragging @property(nonatomic,readonly,getter=isDragging) BOOL dragging; // returns YES if user isn't dragging (touch up) but scroll view is still moving @property(nonatomic,readonly,getter=isDecelerating) BOOL decelerating; 在滚动和滚动结束时，这三个属性的值都不相同。我们利用这三个属性，完成对 UIScrollView 停止滚动的监听。 停止类型1： - (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView; tracking:0,dragging:0,decelerating:0 停止类型2： - (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate; tracking:1,dragging:0,decelerating:1 - (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView; tracking:0,dragging:0,decelerating:0 停止类型3： - (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate; tracking:1,dragging:0,decelerating:0 通过上面的代码，可以发现，我们只需要对 UIScrollView 的这三个属性进行相应的组合，就可以监听到 UIScrollView 停止滚动的事件了。 - (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView { // 停止类型1、停止类型2 BOOL scrollToScrollStop = !scrollView.tracking && !scrollView.dragging && !scrollView.decelerating; if (scrollToScrollStop) { [self scrollViewDidEndScroll]; } } - (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate { if (!decelerate) { // 停止类型3 BOOL dragToDragStop = scrollView.tracking && !scrollView.dragging && !scrollView.decelerating; if (dragToDragStop) { [self scrollViewDidEndScroll]; } } } #pragma mark - scrollView 滚动停止 - (void)scrollViewDidEndScroll { NSLog(@\"停止滚动了！！！\"); } 上面的代码具体请看 监听UIScrollView停止滚动的Demo 中的Demo6-UIScrollView停止滚动 添加停止滚动的回调 Hook setDelegate 因为我们要对 UIScrollView 的 setDelegate 进行方替换，因此我们需要创建一个创建一个 UIScrollView 的 Category ，在 load 中进行替换。 使用dispatch_once包住替换方法的代码，保证只进行一次替换操作，不会因多次替换同一方法，产生隐患。 我这边只想对 UIScrollView 添加滚动停止的监听，所以在 hook_setDelegate 进行了判断，如果是 [UIScrollView class] 才会去Hook系统的代理方法。 + (void)load { static dispatch_once_t onceToken; dispatch_once(&onceToken, ^{ Method originalMethod = class_getInstanceMethod([UIScrollView class], @selector(setDelegate:)); Method replaceMethod = class_getInstanceMethod([UIScrollView class], @selector(hook_setDelegate:)); method_exchangeImplementations(originalMethod, replaceMethod); }); } - (void)hook_setDelegate:(id)delegate { [self hook_setDelegate:delegate]; if ([self isMemberOfClass:[UIScrollView class]]) { NSLog(@\"是UIScrollView，hook方法\"); //Hook (scrollViewDidEndDecelerating:) 方法 Hook_Method([delegate class], @selector(scrollViewDidEndDecelerating:), [self class], @selector(p_scrollViewDidEndDecelerating:), @selector(add_scrollViewDidEndDecelerating:)); //Hook (scrollViewDidEndDragging:willDecelerate:) 方法 Hook_Method([delegate class], @selector(scrollViewDidEndDragging:willDecelerate:), [self class], @selector(p_scrollViewDidEndDragging:willDecelerate:), @selector(add_scrollViewDidEndDragging:willDecelerate:)); } else { NSLog(@\"不是UIScrollView，不需要hook方法\"); } } Hook Method 如果我们想要hook某个代理方法，我们需要考虑这几种情况： 代理对象实现了 scrollViewDidEndDecelerating: 方法，那么我们直接交换就行。 代理对象如果没有实现 scrollViewDidEndDecelerating: 方法，而我们又想监听时，就需要我们动态的添加 scrollViewDidEndDecelerating: 方法。 setDelegate: 万一重复设置了，会导致 scrollViewDidEndDecelerating: 多次交换，我们需要预防这种情况。 static void Hook_Method(Class originalClass, SEL originalSel, Class replacedClass, SEL replacedSel, SEL noneSel){ // 原实例方法 Method originalMethod = class_getInstanceMethod(originalClass, originalSel); // 替换的实例方法 Method replacedMethod = class_getInstanceMethod(replacedClass, replacedSel); // 如果没有实现 delegate 方法，则手动动态添加 if (!originalMethod) { Method noneMethod = class_getInstanceMethod(replacedClass, noneSel); BOOL addNoneMethod = class_addMethod(originalClass, originalSel, method_getImplementation(noneMethod), method_getTypeEncoding(noneMethod)); if (addNoneMethod) { NSLog(@\"******** 没有实现 (%@) 方法，手动添加成功！！\",NSStringFromSelector(originalSel)); } return; } // 向实现 delegate 的类中添加新的方法 // 这里是向 originalClass 的 replaceSel（@selector(p_scrollViewDidEndDecelerating:)） 添加 replaceMethod BOOL addMethod = class_addMethod(originalClass, replacedSel, method_getImplementation(replacedMethod), method_getTypeEncoding(replacedMethod)); if (addMethod) { // 添加成功 NSLog(@\"******** 实现了 (%@) 方法并成功 Hook 为 --> (%@)\", NSStringFromSelector(originalSel), NSStringFromSelector(replacedSel)); // 重新拿到添加被添加的 method,这里是关键(注意这里 originalClass, 不 replacedClass), 因为替换的方法已经添加到原类中了, 应该交换原类中的两个方法 Method newMethod = class_getInstanceMethod(originalClass, replacedSel); // 实现交换 method_exchangeImplementations(originalMethod, newMethod); }else{ // 添加失败，则说明已经 hook 过该类的 delegate 方法，防止多次交换。 NSLog(@\"******** 已替换过，避免多次替换 --> (%@)\",NSStringFromClass(originalClass)); } } 实现我们自己方法 // 已经实现需要hook的代理方法时，调用此处方法进行替换 #pragma mark - Replace_Method - (void)p_scrollViewDidEndDecelerating:(UIScrollView *)scrollView { NSLog(@\"%s\", __func__); [self p_scrollViewDidEndDecelerating:scrollView]; // 停止类型1、停止类型2 BOOL scrollToScrollStop = !scrollView.tracking && !scrollView.dragging && !scrollView.decelerating; if (scrollToScrollStop) { [scrollView stopScroll:scrollView]; } } - (void)p_scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate { NSLog(@\"%s\", __func__); [self p_scrollViewDidEndDragging:scrollView willDecelerate:decelerate]; if (!decelerate) { // 停止类型3 BOOL dragToDragStop = scrollView.tracking && !scrollView.dragging && !scrollView.decelerating; if (dragToDragStop) { [scrollView stopScroll:scrollView]; } } } // 那没有实现需要hook的代理方法时，调用此处方法 #pragma mark - Add_Method - (void)add_scrollViewDidEndDecelerating:(UIScrollView *)scrollView { NSLog(@\"%s\", __func__); // 停止类型1、停止类型2 BOOL scrollToScrollStop = !scrollView.tracking && !scrollView.dragging && !scrollView.decelerating; if (scrollToScrollStop) { [scrollView stopScroll:scrollView]; } } - (void)add_scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate { NSLog(@\"%s\", __func__); if (!decelerate) { // 停止类型3 BOOL dragToDragStop = scrollView.tracking && !scrollView.dragging && !scrollView.decelerating; if (dragToDragStop) { [scrollView stopScroll:scrollView]; } } } #pragma mark - scrollView 滚动停止时触发的方法 - (void)stopScroll:(UIScrollView *)scrollView { NSLog(@\"滚动已停止\"); } 添加回调 接下来，再通过 Runtime 在 Category 中对 UIScrollView 添加一个回调属性stopScrollBlock。 UIScrollView+Category.h文件 @property(nonatomic, copy) StopScrollBlock stopScrollBlock; UIScrollView+Category.m文件 static const char p_stopScrollBlock = '\\0'; - (StopScrollBlock)stopScrollBlock { return objc_getAssociatedObject(self, &p_stopScrollBlock); } - (void)setStopScrollBlock:(StopScrollBlock)stopScrollBlock { objc_setAssociatedObject(self, &p_stopScrollBlock, stopScrollBlock, OBJC_ASSOCIATION_RETAIN_NONATOMIC); } 最后在监听滚动停止的方法中调用这个回调，就大工告成了。 - (void)stopScroll:(UIScrollView *)scrollView { if (self.stopScrollBlock) { self.stopScrollBlock(scrollView); } } 回调的使用 UIScrollView *scrollView = [[UIScrollView alloc] initWithFrame:CGRectMake(0, 0, kScreenW, kScreenH)]; scrollView.contentSize = CGSizeMake(kScreenW * 8, kScreenH); scrollView.delegate = self; scrollView.stopScrollBlock = ^(UIScrollView *scrollView) { NSLog(@\"停止滑动\"); }; [self.view addSubview:scrollView]; 附 UITableView、UICollectionView 滚动结束的监测 Method Swizzling 实战：Hook 系统代理方法 Title: Hook 系统代理方法 Date: 2018.01.14 Author: zhangpeng Github: https://github.com/fullstack-zhangpeng Copyright © zhang peng 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-07-22 10:44:14 "},"ios/create-qr-code.html":{"url":"ios/create-qr-code.html","title":"二维码生成及定制","keywords":"","body":"二维码生成及定制 目前比较常见的二维码库有ZXing，ZBar等，网上对于这些知名库的使用及分析已经很多了，在这就不做赘述了。我们本篇文章的目标是采用 CIQRCodeGenerator 来完成二维码的生成及定制化。 CIQRCodeGenerator 在iOS7之后，苹果自身提供的 API，用于方便快捷的集成二维码的生成和读取功能。使用苹果提供的方法好处就在于不用额外引入其他的第三方库，可以减少打包后的 App 大小。 写博客不给Demo的博主都不是好博主，没Demo没 XX。 授人予鱼，不如授人与渔。鱼在上面的Demo中，渔在下面的文章中。 下面开始我的表演。 需求 最近产品看支付宝红包的二维码分享功能不错，于是乎提出了需求： 一个用于分享的二维码，用于跳转到相关页面 添加logo 拼接一个背景图 以上就是写出这篇文章的原因。(๑•̀ㅂ•́)و✧ 生成二维码 我认为这个二维码的需求很多地方都会需要，所以我这边写在了一个UIImage的扩展中，方便以后的使用。 创建二维码图片 引入头文件 CoreImage.h #import 通过 CIFilter 创建一个二维码图片 //创建名为\"CIQRCodeGenerator\"的CIFilter CIFilter *filter = [CIFilter filterWithName:@\"CIQRCodeGenerator\"]; //将filter所有属性设置为默认值 [filter setDefaults]; //将所需尽心转为UTF8的数据，并设置给filter NSData *data = [string dataUsingEncoding:NSUTF8StringEncoding]; [filter setValue:data forKey:@\"inputMessage\"]; //设置二维码的纠错水平，越高纠错水平越高，可以污损的范围越大 /* * L: 7% * M: 15% * Q: 25% * H: 30% */ [filter setValue:@\"H\" forKey:@\"inputCorrectionLevel\"]; //拿到二维码图片，此时的图片不是很清晰，需要二次加工 CIImage *outPutImage = [filter outputImage]; 调整二维码图片清晰度 方法一 /** 调整二维码清晰度 @param img 模糊的二维码图片 @param size 二维码的宽高 @return 清晰的二维码图片 */ - (UIImage *)getHDImgWithCIImage:(CIImage *)img size:(CGSize)size { CGRect extent = CGRectIntegral(img.extent); CGFloat scale = MIN(size.width/CGRectGetWidth(extent), size.height/CGRectGetHeight(extent)); //1.创建bitmap; size_t width = CGRectGetWidth(extent) * scale; size_t height = CGRectGetHeight(extent) * scale; //创建一个DeviceGray颜色空间 CGColorSpaceRef cs = CGColorSpaceCreateDeviceGray(); //CGBitmapContextCreate(void * _Nullable data, size_t width, size_t height, size_t bitsPerComponent, size_t bytesPerRow, CGColorSpaceRef _Nullable space, uint32_t bitmapInfo) //width：图片宽度像素 //height：图片高度像素 //bitsPerComponent：每个颜色的比特值，例如在rgba-32模式下为8 //bitmapInfo：指定的位图应该包含一个alpha通道。 CGContextRef bitmapRef = CGBitmapContextCreate(nil, width, height, 8, 0, cs, (CGBitmapInfo)kCGImageAlphaNone); CIContext *context = [CIContext contextWithOptions:nil]; //创建CoreGraphics image CGImageRef bitmapImage = [context createCGImage:img fromRect:extent]; CGContextSetInterpolationQuality(bitmapRef, kCGInterpolationNone); CGContextScaleCTM(bitmapRef, scale, scale); CGContextDrawImage(bitmapRef, extent, bitmapImage); //2.保存bitmap到图片 CGImageRef scaledImage = CGBitmapContextCreateImage(bitmapRef); CGContextRelease(bitmapRef); CGImageRelease(bitmapImage); //清晰的二维码图片 UIImage *outputImage = [UIImage imageWithCGImage:scaledImage]; return outputImage; } 方法二 相对于方法一，这个方法可以更方便的修改二维码的颜色 /** 调整二维码清晰度 @param img 模糊的二维码图片 @param size 二维码的宽高 @return 清晰的二维码图片 */ - (UIImage *)sencond_getHDImgWithCIImage:(CIImage *)img size:(CGSize)size { //二维码的颜色 UIColor *pointColor = [UIColor blackColor]; //背景颜色 UIColor *backgroundColor = [UIColor whiteColor]; CIFilter *colorFilter = [CIFilter filterWithName:@\"CIFalseColor\" keysAndValues: @\"inputImage\", img, @\"inputColor0\", [CIColor colorWithCGColor:pointColor.CGColor], @\"inputColor1\", [CIColor colorWithCGColor:backgroundColor.CGColor], nil]; CIImage *qrImage = colorFilter.outputImage; //绘制 CGImageRef cgImage = [[CIContext contextWithOptions:nil] createCGImage:qrImage fromRect:qrImage.extent]; UIGraphicsBeginImageContext(size); CGContextRef context = UIGraphicsGetCurrentContext(); CGContextSetInterpolationQuality(context, kCGInterpolationNone); CGContextScaleCTM(context, 1.0, -1.0); CGContextDrawImage(context, CGContextGetClipBoundingBox(context), cgImage); UIImage *codeImage = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); CGImageRelease(cgImage); return codeImage; } 通过上面两部，就可以得到一张清晰的二维码图片了。 定制二维码 修改二维码颜色 当我美滋滋的生成一个二维码图片以后，有个 Android 的同事说可以把二维码周围的白边去掉，这个真的是程序员给程序员找麻烦~ 修改二维码的原理是改变每个像素点的颜色，具体代码如下： /** 修改二维码颜色 @param image 二维码图片 @param red red @param green green @param blue blue @return 修改颜色后的二维码图片 */ + (UIImage *)changeColorWithQRCodeImg:(UIImage *)image red:(NSUInteger)red green:(NSUInteger)green blue:(NSUInteger)blue { const int imageWidth = image.size.width; const int imageHeight = image.size.height; size_t bytesPerRow = imageWidth * 4; uint32_t * rgbImageBuf = (uint32_t *)malloc(bytesPerRow * imageHeight); CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB(); CGContextRef context = CGBitmapContextCreate(rgbImageBuf, imageWidth, imageHeight, 8, bytesPerRow, colorSpace, kCGBitmapByteOrder32Little | kCGImageAlphaNoneSkipLast); CGContextDrawImage(context, (CGRect){(CGPointZero), (image.size)}, image.CGImage); //遍历像素 int pixelNumber = imageHeight * imageWidth; [self changeColorOnPixel:rgbImageBuf pixelNum:pixelNumber red:red green:green blue:blue]; CGDataProviderRef dataProvider = CGDataProviderCreateWithData(NULL, rgbImageBuf, bytesPerRow, ProviderReleaseData); CGImageRef imageRef = CGImageCreate(imageWidth, imageHeight, 8, 32, bytesPerRow, colorSpace, kCGImageAlphaLast | kCGBitmapByteOrder32Little, dataProvider, NULL, true, kCGRenderingIntentDefault); UIImage * resultImage = [UIImage imageWithCGImage: imageRef]; CGImageRelease(imageRef); CGColorSpaceRelease(colorSpace); CGContextRelease(context); return resultImage; } /** 遍历像素点，修改颜色 @param rgbImageBuf rgbImageBuf @param pixelNum pixelNum @param red red @param green green @param blue blue */ + (void)changeColorOnPixel: (uint32_t *)rgbImageBuf pixelNum: (int)pixelNum red: (NSUInteger)red green: (NSUInteger)green blue: (NSUInteger)blue { uint32_t * pCurPtr = rgbImageBuf; for (int i = 0; i 添加水印图片（Logo） /** 调整二维码清晰度，添加水印图片 @param img 模糊的二维码图片 @param size 二维码的宽高 @param waterImg 水印图片 @return 添加水印图片后，清晰的二维码图片 */ - (UIImage *)getHDImgWithCIImage:(CIImage *)img size:(CGSize)size waterImg:(UIImage *)waterImg { CGRect extent = CGRectIntegral(img.extent); CGFloat scale = MIN(size.width/CGRectGetWidth(extent), size.height/CGRectGetHeight(extent)); //1.创建bitmap; size_t width = CGRectGetWidth(extent) * scale; size_t height = CGRectGetHeight(extent) * scale; //创建一个DeviceGray颜色空间 CGColorSpaceRef cs = CGColorSpaceCreateDeviceGray(); //CGBitmapContextCreate(void * _Nullable data, size_t width, size_t height, size_t bitsPerComponent, size_t bytesPerRow, CGColorSpaceRef _Nullable space, uint32_t bitmapInfo) //width：图片宽度像素 //height：图片高度像素 //bitsPerComponent：每个颜色的比特值，例如在rgba-32模式下为8 //bitmapInfo：指定的位图应该包含一个alpha通道。 CGContextRef bitmapRef = CGBitmapContextCreate(nil, width, height, 8, 0, cs, (CGBitmapInfo)kCGImageAlphaNone); CIContext *context = [CIContext contextWithOptions:nil]; //创建CoreGraphics image CGImageRef bitmapImage = [context createCGImage:img fromRect:extent]; CGContextSetInterpolationQuality(bitmapRef, kCGInterpolationNone); CGContextScaleCTM(bitmapRef, scale, scale); CGContextDrawImage(bitmapRef, extent, bitmapImage); //2.保存bitmap到图片 CGImageRef scaledImage = CGBitmapContextCreateImage(bitmapRef); CGContextRelease(bitmapRef); CGImageRelease(bitmapImage); //清晰的二维码图片 UIImage *outputImage = [UIImage imageWithCGImage:scaledImage]; //给二维码加 logo 图 UIGraphicsBeginImageContextWithOptions(outputImage.size, NO, [[UIScreen mainScreen] scale]); [outputImage drawInRect:CGRectMake(0, 0, size.width, size.height)]; //水印图片 //把水印图片画到生成的二维码图片上，注意尺寸不要太大（根据上面生成二维码设置的纠错程度设置），否则有可能造成扫不出来 [waterImg drawInRect:CGRectMake((size.width-waterImg.size.width)/2.0, (size.height-waterImg.size.height)/2.0, waterImg.size.width, waterImg.size.height)]; UIImage *newPic = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return newPic; } 拼接图片 /** 拼接图片 @param img1 图片1 @param img2 图片2 @param location 图片2相对于图片1的左上角位置 @return 拼接后的图片 */ + (UIImage *)spliceImg1:(UIImage *)img1 img2:(UIImage *)img2 img2Location:(CGPoint)location { // CGSize size1 = img1.size; CGSize size2 = img2.size; UIGraphicsBeginImageContextWithOptions(img1.size, NO, [[UIScreen mainScreen] scale]); [img1 drawInRect:CGRectMake(0, 0, img1.size.width, img1.size.height)]; // [img2 drawInRect:CGRectMake((size1.width-size2.width)/2.0, (size1.height-size2.height)/2.0, size2.width, size2.height)]; // [img2 drawInRect:CGRectMake(size1.width/4.0, size1.height/2.5, size1.width/2, size1.width/2)]; [img2 drawInRect:CGRectMake(location.x, location.y, size2.width, size2.height)]; UIImage *newPic = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return newPic; } 附 官方对于CIQRCodeGenerator的介绍 Title: 二维码生成及定制 Date: 2017.12.15 Author: zhangpeng Github: https://github.com/fullstack-zhangpeng Copyright © zhang peng 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-07-22 10:44:14 "},"ios/wkwebview.html":{"url":"ios/wkwebview.html","title":"WKWebView 使用及注意事项","keywords":"","body":"WKWebView 使用及注意事项 WKWebView 是苹果提供的用于在App中进行网页浏览的控件，不过只能在 iOS8 后使用，如果还需要适配 iOS7，那我只能摆一张无奈脸了ㄟ( ▔， ▔ )ㄏ 为什么使用要用 WKWebView 它相对于 UIWebView 有以下几个优点： 性能和稳定性的大幅提高 内存占用的减少 支持更多HTML5特性 60fps的刷新率以及内置手势的支持 增加了新的代理方法，可控性更高 更多内容可以查看 WebKit苹果官方链接 如何使用 引入 WebKit 要想使用WKWebView，一定要先引入: #import 添加 WKWebView // WKUserContentController 对象为 JavaScript 提供了一种方式，可以将消息发送到 web 视图，并将用户脚本注入到 web 视图中。 WKUserContentController *userContentController = [[WKUserContentController alloc] init]; // 执行 js，添加 cookies NSString *js = @\"document.cookie='userId=zhangpeng'\"; WKUserScript * cookieScript = [[WKUserScript alloc] initWithSource:js injectionTime:WKUserScriptInjectionTimeAtDocumentStart forMainFrameOnly:NO]; [userContentController addUserScript:cookieScript]; // 用于初始化 web 视图的配置 WKWebViewConfiguration *config = [[WKWebViewConfiguration alloc] init]; config.userContentController = userContentController; _config = config; // 注入 JS 对象名称，当 JS 通过对象名称来调用时，我们可以在 WKScriptMessageHandler 代理中接收到 for (NSString *scriptMessage in self.scriptMessages) { [config.userContentController addScriptMessageHandler:self name:scriptMessage]; } WKWebView *webView = [[WKWebView alloc] initWithFrame:CGRectMake(0, 0, kScreenW, kMainAreaHeightNoTab) configuration:config]; /* UIDelegate: web view 的用户界面代理。 WKUIDelegate类提供了代表网页呈现本地用户界面元素的方法。 */ webView.UIDelegate = self; /* navigationDelegate: web view 的导航代理。 WKNavigationDelegate协议的方法帮助您实现在web view接受、加载和完成导航请求过程中触发的自定义行为。 */ webView.navigationDelegate = self; [self.view addSubview:webView]; _webView = webView; 代理方法 WKNavigationDelegate WKNavigationDelegate 中基本都是生命周期相关的代理，下面会按照执行顺序进行介绍 // 1.是否允许跳转 - (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler{ NSLog(@\"%s\", __func__); decisionHandler(WKNavigationActionPolicyAllow); } // 2.开始加载网页 - (void)webView:(WKWebView *)webView didStartProvisionalNavigation:(WKNavigation *)navigation { NSLog(@\"%s\", __func__); } // 3.知道返回内容之后，是否允许加载 - (void)webView:(WKWebView *)webView decidePolicyForNavigationResponse:(WKNavigationResponse *)navigationResponse decisionHandler:(void (^)(WKNavigationResponsePolicy))decisionHandler{ NSLog(@\"%s\", __func__); decisionHandler(WKNavigationResponsePolicyAllow); } /// 4.当内容开始返回时调用 - (void)webView:(WKWebView *)webView didCommitNavigation:(WKNavigation *)navigation { NSLog(@\"%s\", __func__); } // 5.页面加载完成之后调用 - (void)webView:(WKWebView *)webView didFinishNavigation:(WKNavigation *)navigation { NSLog(@\"%s\", __func__); } // 当跳转失败时调用 - (void)webView:(WKWebView *)webView didFailNavigation:(WKNavigation *)navigation withError:(NSError *)error { NSLog(@\"%s\", __func__); } // 当web view加载内容失败时调用 - (void)webView:(WKWebView *)webView didFailProvisionalNavigation:(WKNavigation *)navigation { NSLog(@\"%s\", __func__); } 下面还有几个不常用但是要知道的代理 //当由服务端进行重定向时触发 - (void)webView:(WKWebView *)webView didReceiveServerRedirectForProvisionalNavigation:(null_unspecified WKNavigation *)navigation{ NSLog(@\"%s\", __func__); } //进行证书验证时触发 - (void)webView:(WKWebView *)webView didReceiveAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition, NSURLCredential * _Nullable))completionHandler { NSLog(@\"%s\", __func__); NSURLCredential *card = [[NSURLCredential alloc]initWithTrust:challenge.protectionSpace.serverTrust]; completionHandler(NSURLSessionAuthChallengeUseCredential, card); } //当因为某些问题，导致webView进程终止时触发 - (void)webViewWebContentProcessDidTerminate:(WKWebView *)webView { NSLog(@\"%s\", __func__); } WKUIDelegate WKUIDelegate 中我们最常用的就是这个 - (void)webView:(WKWebView *)webView runJavaScriptAlertPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(void))completionHandler 代理了。我们可以在这个代理中，将前端中的 alert() 替换为我们自己的弹窗。 - (void)webView:(WKWebView *)webView runJavaScriptAlertPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(void))completionHandler { UIAlertController *alert = [UIAlertController alertControllerWithTitle:@\"提示\" message:message preferredStyle:UIAlertControllerStyleAlert]; UIAlertAction *cancelAction = [UIAlertAction actionWithTitle:@\"确定\" style:UIAlertActionStyleCancel handler:nil]; [alert addAction:cancelAction]; [self presentViewController:alert animated:YES completion:nil]; completionHandler(); } 这个 message 就是前端通过alert()方法传递的内容。一定要写上 completionHandler();，否则在某些情况下会造成Crash，详见 WKWebView那些坑。 下面两个方法，和上面的蕾丝，如有需要，可以看情况使用。 - (void)webView:(WKWebView *)webView runJavaScriptConfirmPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(BOOL result))completionHandler; - (void)webView:(WKWebView *)webView runJavaScriptTextInputPanelWithPrompt:(NSString *)prompt defaultText:(nullable NSString *)defaultText initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(NSString * _Nullable result))completionHandler; 与js交互 客户端与 JS 交互，有两种方案： 通过 webkit.messageHandlers 进行交互； 通过拦截跳转地址进行交互； 下面我们来分别讲讲如何实现： 通过 webkit.messageHandlers 进行交互 这种方案需要我们客户端提前在端上做些准备。我们需要在 - (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message 代理中写好路由方法，简单来讲就是什么消息体该做什么事。当前端同学通过特定方法调用功能时，我们可以在此代理中接收到消息体，然后我们根据不同的消息内容，进行不同的操作即可。 - (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message { // 打印所传过来的参数，只支持NSNumber, NSString, NSDate, NSArray, NSDictionary, NSNull类型 if ([message.name isEqualToString:@\"test1\"]) { NSLog(@\"触发了test1\"); } else if ([message.name isEqualToString:@\"test2\"]) { NSLog(@\"触发了test2\"); } else { } } 通过查看 WKScriptMessage，我们可以看到 name 和 body 两个属性，name 就是注入的 js 对象名称，body 就是前端传给我们的参数。我们根据不同的 name 进行判断，执行不同的操作。举个例子：当前端同学调用 test1 时就会打印 触发了test1，而调用 test2 时就会打印 触发了test2。 而前端同学就简单了，当需要调用客户端中的方法时，通过下面的方式进行调用及传参：window.webkit.messageHandlers.对象.postMessage(参数); 对象：就是我们在初始化WKWebView时，通过addScriptMessageHandler 注入的 js 对象名称； 参数：建议用json进行参数的传递，两边约定好的规范，可以提高开发的效率 举个例子： window.webkit.messageHandlers.test1.postMessage({msg: \"test1\"}); 通过拦截跳转地址进行交互 拦截跳转地址的玩法，和 UIWebView 的玩法一致，在代理中进行拦截，如果有特定的表示，则停止跳转，然后解析 url，做不同的事情。 常见问题 添加Cookies JS 注入的 Cookie，比如 PHP 代码在 Cookie 容器中取是取不到的，javascript 中的 document.cookie 能读取到，浏览器中也能看到。 NSMutableURLRequest 注入的 PHP 等动态语言直接能从 $_COOKIE 对象中获取到，但是 js 读取不到，浏览器也看不到。 所以我们的解决办法是： 在初始化时，通过 js 注入添加 cookies // WKUserContentController对象为JavaScript提供了一种方式，可以将消息发送到web视图，并将用户脚本注入到web视图中。 WKUserContentController *userContentController = [[WKUserContentController alloc] init]; // 执行js，添加cookies NSString *js = @\"document.cookie='userId=zhangpeng'\"; WKUserScript * cookieScript = [[WKUserScript alloc] initWithSource:js injectionTime:WKUserScriptInjectionTimeAtDocumentStart forMainFrameOnly:NO]; [userContentController addUserScript:cookieScript]; 给发出的 request 也添加上 cookies NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:url cachePolicy:NSURLRequestReloadIgnoringLocalCacheData timeoutInterval:20.0f]; [request setValue:@\"userId=zhangpeng\" forHTTPHeaderField:@\"Cookie\"]; [_webView loadRequest:request]; WKWebView内存泄漏 问题描述 通过持有 WKWebView 在 dealloc 方法打断点，可以看到控制器并没有走到该方法，猜想是由于 WKUserContentController 对象的 addScriptMessageHandler 方法强引用了控制器本身，而控制器又强引用了 webView，然后 webView 又强引用了 configuration， configuration 又强引用了 WKUserContentController 对象，最终造成了不能释放。通过搜索看到了stackoverflow中的一个解决方案，最终解决了问题。 解决方案 1.创建一个新类WeakScriptMessageDelegate #import #import @interface WeakScriptMessageDelegate : NSObject @property (nonatomic, weak) id scriptDelegate; - (instancetype)initWithDelegate:(id)scriptDelegate; @end @implementation WeakScriptMessageDelegate - (instancetype)initWithDelegate:(id)scriptDelegate { self = [super init]; if (self) { _scriptDelegate = scriptDelegate; } return self; } - (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message { [self.scriptDelegate userContentController:userContentController didReceiveScriptMessage:message]; } @end 2.在我们使用 WKWebView 的控制器中引入我们创建的那个类，将注入 js 对象的代码改为: [config.userContentController addScriptMessageHandler:[[WeakScriptMessageDelegate alloc] initWithDelegate:self] name:scriptMessage]; 3.在 delloc 方法中通过下面的方式移除注入的 js 对象 [self.config.userContentController removeScriptMessageHandlerForName:scriptMessage]; 上面三步就可以解决控制器不能被释放的问题了。O(∩_∩)O~~ 附 1.WKWebView那些坑 本文的所有代码均以上传至 GitHub，如需自取～ Title: WKWebView 使用及注意事项 Date: 2017.12.03 Author: zhangpeng Github: https://github.com/fullstack-zhangpeng Copyright © zhang peng 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-07-22 10:44:14 "},"ios/interview.html":{"url":"ios/interview.html","title":"面试啊面试~","keywords":"","body":"面试啊面试~ 下面代码打印 true 还是 false？ id arr = [[NSArray alloc] init]; if ([[arr class] isKindOfClass:[NSArray class]]) { NSLog(@\"true\"); } else { NSLog(@\"false\"); } 答案： 打印 false 分析： 因为 NSArray 运用了类蔟 (Class clusters) 的设计模式，类簇其实是对现实的一种抽象和封装，基于抽象工厂模式 (Abstract Factory Pattern)。NSNumber、NSString、NSArray等均是如此。 如想更深入的了解相关概念，可以查阅下面两篇文章： Sunny大神写的《从NSArray看类簇》 《Objective-C类族和工厂模式》 代码在请见Demo中的 Demo2 下面代码打印什么内容？ NSMutableSet *mSet = [[NSMutableSet alloc] init]; [mSet addObject:@[@1, @2]]; NSLog(@\"1---%@\", mSet); NSMutableArray *mArr = [[NSMutableArray alloc] initWithObjects:@1, nil]; [mSet addObject:mArr]; NSLog(@\"2---%@\", mSet); [mArr addObject:@2]; NSLog(@\"3---%@\", mSet); [mSet addObject:@[@1, @2]]; NSLog(@\"4---%@\", mSet); 答案： 分析： 集合（NSMutableSet）和数组（NSMutableArray）有相似之处，都是存储不同的对象的地址；不过NSMutableArray是有序的集合，NSMutableSet是无序的集合。 集合是一种哈希表，运用散列算法，查找集合中的元素比数组速度更快，但是它没有顺序。当插入相同的数据时，不会有任何效果。 第一次输出时，创建了一个包含 @[@1, @2] 的 NSMutableSet第二次输出时，向已经创建的 mSet 中添加一个可变数组第三次输出时，向前面创建的 mArr 中添加一个 @2，可以成功的将 @[@1, @2] 这个 mArr 添加到 mSet 中，应该是因为 @[@1, @2] 是 __NSArrayI，mArr 是 __NSArrayM ,不能成功的判断相等第四次输出时，由于集合内已经存在相同的 @[@1, @2]，而 mSet 中的元素是不能重复的，所以没有成功添加 代码在请见Demo中的Demo3 Title: 面试啊面试~ Date: 2017.11.09 Author: zhangpeng Github: https://github.com/fullstack-zhangpeng Copyright © zhang peng 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-07-22 10:44:14 "},"ios/double-to-nsstring.html":{"url":"ios/double-to-nsstring.html","title":"double 转 NSString 出现精度异常","keywords":"","body":"double 转 NSString 出现精度异常 在日常开发中，后台再给我们返回数字类型的数据时，很有可能是带小数点的。我们只能用 float 或者 double 去接，我们如果需要显示给用户时，就会造成精度异常。 错误事例 { \"double\": 79.04, } 上面是服务端给我们返回的 response，我们将它转为字典. NSDictionary *dic = [NSJSONSerialization JSONObjectWithData:data options:0 error:nil]; [NSString stringWithFormat:@\"转换错误的结果为%@\", dic[@\"double\"]]; 到这，也许有人会说：在转字符串时，加上保留的位数就可以了。但其实这样做并不是太合理。因为我们根本不服务端后台会给我们返回什么数据，所以我们不知道该保留几位小数。同理，我们也不能采取切割字符串的方式去保留小数位数。 解决办法 采用苹果提供的NSDecimalNumber解决此问题。 double d = [dic[@\"double\"] doubleValue]; NSString *dStr = [NSString stringWithFormat:@\"%f\", d]; NSDecimalNumber *dn = [NSDecimalNumber decimalNumberWithString:dStr]; [NSString stringWithFormat:@\"转换成功的结果为%@\", dn.stringValue]; 本文的所有代码均以上传至 GitHub，如需自取~ Title: double 转 NSString 出现精度异常 Date: 2017.09.08 Author: zhangpeng Github: https://github.com/fullstack-zhangpeng Copyright © zhang peng 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-07-22 10:44:14 "},"ios/widget-development.html":{"url":"ios/widget-development.html","title":"Widget 开发-开发篇","keywords":"","body":"Widget 开发-开发篇 开发步骤 建议先阅读Widget 开发-配置篇，再开始开发，因为开发的过程中需要提前准备一些东西 创建新的 Target，选择 Today Extension 创建完成后，会生成如下图的几个文件。 修改 Today Extension 的 Info.plist Bundle display nameWidget在通知栏显示的名称 NSExtension如果你是使用纯代码进行开发，请按照下面进行操作： 请删除 NSExtensionMainStoryboard 的键值对和 MainInterface.storyboard 文件 请添加 NSExtensionPrincipalClass 这个 key，并将 value 设置为控制器（如 TodayViewController） 准备工作都已经完成，可以进入开发工作 Widget 的开发并没有多难，照着文档足以开发出一个很漂亮的 Wiget 了，不过有些版本差异要注意下。 iOS8 在 iOS8 中没有折叠和展开功能，默认的 Widget 高度为 self.preferredContentSize 设置的高度。 self.preferredContentSize = CGSizeMake(kScreenW, 100); iOS8 下所有组件默认右移30单位，可以通过下面的方法修改上下左右的距离 - (UIEdgeInsets)widgetMarginInsetsForProposedMarginInsets:(UIEdgeInsets)defaultMarginInsets { return UIEdgeInsetsMake(0, 0, 0, 0); } iOS10 iOS10 以后，Widget 可玩性变得更高了，有了两种显示模式: NCWidgetDisplayModeCompact // Fixed height，高度固定，最低高度为110 NCWidgetDisplayModeExpanded // Variable height，高度可变 // 5s模拟器下: // NCWidgetDisplayModeCompact模式下:{304, 110} // NCWidgetDisplayModeExpanded模式下:{304, 528} // 6s模拟器下： // NCWidgetDisplayModeCompact模式下:{359, 110} // NCWidgetDisplayModeExpanded模式下:{359, 616} 设定显示模式，需要在设定 Size 前设定这个属性，代码如下： - (void)viewDidLoad { [super viewDidLoad]; if ([[UIDevice currentDevice] systemVersion].intValue >= 10) { self.extensionContext.widgetLargestAvailableDisplayMode = NCWidgetDisplayModeCompact; // self.extensionContext.widgetLargestAvailableDisplayMode = NCWidgetDisplayModeExpanded; } self.preferredContentSize = CGSizeMake(kScreenW, 100); [self setupUI]; } 当显示模式设置为 NCWidgetDisplayModeExpanded 时，点击折叠和打开时，会触发下面这个方法，在这个方法中可以修改对应状态的高度。修改完毕后，更新视图即可看到最新的布局。 - (void)widgetActiveDisplayModeDidChange:(NCWidgetDisplayMode)activeDisplayMode withMaximumSize:(CGSize)maxSize { if (activeDisplayMode == NCWidgetDisplayModeCompact) { self.preferredContentSize = CGSizeMake(maxSize.width, 110); } else { self.preferredContentSize = CGSizeMake(maxSize.width, 200); } } //在下面的方法中更新视图 -(void)widgetPerformUpdateWithCompletionHandler:(void (^)(NCUpdateResult))completionHandler { // NCUpdateResultNewData 新的内容需要重新绘制视图 // NCUpdateResultNoData 部件不需要更新 // NCUpdateResultFailed 更新过程中发生错误 completionHandler(NCUpdateResultNoData); } 可能会遇上的问题&解决办法 代码共享 目前我见到了四种共享代码的方法： 将代码打包成 Framework，然后 link 到主 App和 Widget 中 （推荐） 不怕安装包变大的话，可以考虑将需要的第三方库在主 App 和 Widget 中分别复制一份 （推荐） 将需要共享的文件按图中进行勾选配置 通过 Pods 导入，不太建议通过 Pods 分别向两个 Target 中导入第三方库，因为很容易发生一些不好处理的问题 数据共享 数据共享有两种常用的方法： NSUserDefaults和我们常用的方法一样，不过在创建 NSUserDefaults 时，需要填写我们之前的 GroupID。通过 GroupID，我们就可以进行主 App 和 Widget 之间的数据共享了。 // 写入数据 NSString *groupID = @\"group.com.aaa.bbb\"; NSUserDefaults *ud = [[NSUserDefaults alloc] initWithSuiteName:groupID];[ud setObject:@\"我是测试的数据\" forKey:@\"test\"]; [ud synchronize]; // 读取数据 NSString *groupID = @\"group.com.aaa.bbb\"; NSUserDefaults *ud = [[NSUserDefaults alloc] initWithSuiteName:groupID]; NSString *value = [ud objectForKey:@\"test\"]; NSFileManager // 写入数据 NSString *groupID = @\"group.com.aaa.bbb\"; NSError *err = nil; NSURL *containerURL = [[NSFileManager defaultManager] containerURLForSecurityApplicationGroupIdentifier:groupID]; containerURL = [containerURL URLByAppendingPathComponent:@\"Library/Caches/test\"]; NSString *value = @\"我是测试的数据\"; BOOL result = [value writeToURL:containerURL atomically:YES encoding:NSUTF8StringEncoding error:&err]; if(result){ NSLog(@\"写入成功\"); } // 读取数据 NSString *groupID = @\"group.com.aaa.bbb\"; NSError *err = nil; NSURL *containerURL = [[NSFileManager defaultManager] containerURLForSecurityApplicationGroupIdentifier:groupID]; containerURL = [containerURL URLByAppendingPathComponent:@\"Library/Caches/test\"]; NSString *value = [NSString stringWithContentsOfURL:containerURL encoding:NSUTF8StringEncoding error:&err]; 数据刷新 当widget从屏幕上消失2s左右，再次出现在屏幕中时，都会重新调用viewDidLoad方法。所以每次出现都请求最新数据，进行刷新操作，widget都会闪一下，根据产品需求，可以做一下控制； - (void)viewDidLoad { [super viewDidLoad]; } 如果短时间内让Widget频繁地消失显示，那只会执行viewWillAppear方法； - (void)viewWillAppear:(BOOL)animated { [super viewWillAppear:animated]; } 打开 App 设置 App 的 URLSchemes，打开 APP 主要通过 URLScheme 打开和传递参数值。 设置 URLSchemes 时，要独特一些，避免与其他 App 重复 在 Widget 中添加点击事件，用于触发打开 App 的操作和传递参数 NSString *schemeString = @\"zhangpeng://actionName?paramName=paramValue\"; [self.extensionContext openURL:[NSURL URLWithString:schemeString] completionHandler:^(BOOL success) { }]; Appdelegate 的代理方法中，截取 URL，做响应处理： // 所有版本的都可以使用 - (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation { [self appCallbackWithOpenUrl:url]; return YES; } // iOS 8 以后 - (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary *)options { [self appCallbackWithOpenUrl:url]; return YES; } // iOS 7 - (BOOL)application:(UIApplication *)application handleOpenURL:(NSURL *)url { [self appCallbackWithOpenUrl:url]; return YES; } - (void)appCallbackWithOpenUrl:(NSURL *)url{ NSLog(@\"url: %@\", url.host); // 针对url进行不同的操作 } Title: Widget 开发-开发篇 Date: 2017.09.07 Author: zhangpeng Github: https://github.com/fullstack-zhangpeng Copyright © zhang peng 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-07-22 10:44:14 "},"ios/widget-configuration.html":{"url":"ios/widget-configuration.html","title":"Widget 开发-配置篇","keywords":"","body":"Widget 开发-配置篇 前期准备 申请 GroupID Description 填写这个 App Group 的描述；ID 填写这个 App Group 的标识，建议以 com.{aaa}.{bbb} 命名，填写完毕时，会默认在前面加上 group{aaa}: 公司名字{bbb}: App名字 创建完毕以后，如图所示 将 group 添加到 App ID 中 最后一步，重新激活下 Provisioning Profile 由于操作过 App ID 了，需要重新激活下 Provisioning Profile。至此，帐号相关的工作便完成了。 项目配置 点击进入 App Target 的 Capabilities 页 打开 App Groups 选项，这里会显示已有的 App Groups，勾选上面创建的 App Group 即可。 点击进入 Widget Target 的 General 页 设置 Bundle identifier 命名规则：前缀要包括主项目的 Bundle Identifier。后缀不能是 widget 关键字例如主项目如果是 com.aaa.bbb，那 Widget 的 Bundle identifier 应该是 com.aaa.bbb.today 或者是 com.aaa.bbb.ccc 配置已完成，接下来请看开发篇Widget 开发-开发篇 Title: Widget 开发-配置篇 Date: 2017.08.29 Author: zhangpeng Github: https://github.com/fullstack-zhangpeng Copyright © zhang peng 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-07-22 10:44:14 "},"ios/read-pdf-with-cryptographic-seal.html":{"url":"ios/read-pdf-with-cryptographic-seal.html","title":"读取一个带有加密印章的 PDF","keywords":"","body":"读取一个带有加密印章的 PDF 之前公司在和一个做电子签章的公司合作时，他们给我们提供了一份带有加密印章的 PDF。在测试中发现，不论通过 UIWebView 或者 WKWebView 打开，PDF 中的加密印章都不能成功展示。 通过不断的调研及尝试，最终成功展示出了 PDF 中的加密印章。现在把方法分享给大家～ 本文的所有代码均以上传至 GitHub，如需自取~ 实现步骤 宏 为了方便我进行代码编写，我们提前设置几个宏： #define kScreenW [UIScreen mainScreen].bounds.size.width #define kScreenH [UIScreen mainScreen].bounds.size.height #define DOCUMENTS_DIRECTORY [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject] 详细代码 本文中的 Demo 是以 WKWebView 进行开发，如果您需要使用 UIWebView，请自行修改。 添加 WKWebView ```objc import WKWebViewConfiguration *config = [[WKWebViewConfiguration alloc] init]; WKUserContentController *wkUController = [[WKUserContentController alloc]init]; config.userContentController = wkUController; // 注入JS对象名称AppModel，当JS通过AppModel来调用时，我们可以在WKScriptMessageHandler代理中接收到 // 此处是为了得到PDF加载完成或失败的反馈 [config.userContentController addScriptMessageHandler:self name:@\"AppModel\"]; // 改变页面内容宽度，适配屏幕大小 NSString *js = @\"var meta = document.createElement('meta'); meta.setAttribute('name', 'viewport'); meta.setAttribute('content', 'width=device-width'); document.getElementsByTagName('head')[0].appendChild(meta);\"; WKUserScript *wkUserScript = [[WKUserScript alloc] initWithSource:js injectionTime:WKUserScriptInjectionTimeAtDocumentEnd forMainFrameOnly:YES]; [wkUController addUserScript:wkUserScript]; WKWebView *webView = [[WKWebView alloc] initWithFrame:CGRectMake(0, 0, kScreenW, kScreenH - 64) configuration:config]; webView.backgroundColor = [UIColor whiteColor]; webView.UIDelegate = self; webView.navigationDelegate = self; [self.view addSubview:webView]; ``` 下载PDF NSString *urlStr = @\"http://img.zhangpeng.site/jianLi_zhangpeng.pdf\"; NSURLRequest *request = [NSURLRequest requestWithURL:[NSURL URLWithString:urlStr]]; NSURLSession *session = [NSURLSession sharedSession]; NSURLSessionDataTask *sessionDataTask = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) { NSLog(@\"从服务器获取到pdf数据\"); //对从服务器获取到的数据data进行相应的处理： dispatch_async(dispatch_get_main_queue(), ^{ NSString *path = [DOCUMENTS_DIRECTORY stringByAppendingPathComponent:@\"contract.pdf\"]; NSFileManager *fm = [NSFileManager defaultManager]; if ([fm fileExistsAtPath:path]) { [fm removeItemAtPath:path error:nil]; } BOOL success = [data writeToFile:path atomically:YES]; if (success) { NSLog(@\"保存成功\"); NSURL *baseURL = [NSURL fileURLWithPath:[self getHtmlBasePath]]; NSString *path = [self getHtmlPath]; NSString *htmlStr = [NSString stringWithContentsOfFile:path encoding:NSUTF8StringEncoding error:nil]; [self.webView loadHTMLString:htmlStr baseURL:baseURL]; } }); }]; [sessionDataTask resume]; 打开 PDF - (void)webView:(WKWebView *)webView didFinishNavigation:(WKNavigation *)navigation { [self loadPDF]; } - (void)loadPDF { NSString *path = [DOCUMENTS_DIRECTORY stringByAppendingPathComponent:@\"contract.pdf\"]; NSData *data = [NSData dataWithContentsOfFile:path options:NSDataReadingMappedAlways error:nil]; NSString *paraStr = [data base64EncodedStringWithOptions:NSDataBase64EncodingEndLineWithCarriageReturn]; NSString *js = [NSString stringWithFormat:@\"loadMyJS('%@')\",paraStr]; //NSLOG(@\"%@\",method); [self.webView evaluateJavaScript:js completionHandler:^(id _Nullable response, NSError * _Nullable error) { if (error) { NSLog(@\"%@\", error); NSLog(@\"当前手机系统版本较低，不支持查看，请升级系统或者到PC端查看。\"); } }]; } 在 WKWebView 的代理中，我们可以知道 PDF 是否成功打开， - (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message { if ([message.name isEqualToString:@\"AppModel\"]) { //和customview.js文件交互，js调oc的代码 // 打印所传过来的参数，只支持NSNumber, NSString, NSDate, NSArray, NSDictionary, and NSNull类型 if ([message.body[@\"code\"] isEqualToString:@\"00000\"]) { NSLog(@\"%@\", message.body[@\"msg\"]); } } } PDF 是否读取成功是在 customview.js 中通知控制器的，具体可以查看下面的代码。 function handlePages(page) { //create new canvas var viewport = page.getViewport(1); var canvas = document.createElement( \"canvas\" ); canvas.style.display=\"block\"; var context = canvas.getContext('2d'); canvas.height = viewport.height; canvas.width = viewport.width; //render page page.render({canvasContext: context, viewport: viewport}); //add canvas to body document.body.appendChild(canvas); //render new page pageNum++; if(pdfDoc!=null && pageNum 到此，我们已经可以在 iOS9 以上的系统中，成功打开带加密印章的 PDF。至于 iOS8 为什么不行呢？下面给大家讲解及提供方案。 在 iOS8 上，html 及 js 文件的路径为 tmp 目录下，iOS9 及以上则在 bundle 里。 解决方案： - (NSString*)getHtmlBasePath { NSString *basePath = @\"\"; if ([[[UIDevice currentDevice]systemVersion]floatValue] Title: 读取一个带有加密印章的 PDF Date: 2017.08.29 Author: zhangpeng Github: https://github.com/fullstack-zhangpeng Copyright © zhang peng 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-07-22 10:44:14 "},"leetcode/two-sum.html":{"url":"leetcode/two-sum.html","title":"1. 两数之和","keywords":"","body":"两数之和 \b题目连接：两数之和 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 给定 nums = [2, 7, 11, 15]，target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9，所以返回 [0, 1] 解题思路 创建一个 map，用于存储数组中整数及下标的对应关系，以整数为 key，下标为 value 使用 for 循环遍历给定的数组 用目标值减去每次遍历的结果，然后判断做减结果是不是上面 map 中的 key: 是返回当前遍历的 index，以及上面 map 中以做减结果为 key 对应的 value 否以当前遍历得到的整数为 key，index 为 value 保存到上面 map 中 代码 package main import \"fmt\" func main() { result := twoSum([]int{2, 7, 11, 15}, 9) fmt.Println(result) } func twoSum(nums []int, target int) []int { tempMap := make(map[int]int) for index, value := range nums { result := target - value if _, ok := tempMap[result]; ok { return []int{index, tempMap[result]} } else { tempMap[value] = index } } return nil } Title: 两数之和 Date: 2019.11.20 Author: zhangpeng Github: https://github.com/fullstack-zhangpeng Copyright © zhang peng 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-07-22 10:44:14 "},"leetcode/valid-parentheses.html":{"url":"leetcode/valid-parentheses.html","title":"2. 有效的括号","keywords":"","body":"有效的括号 \b题目连接：有效的括号 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。 示例 1: 输入: \"()\"输出: true 示例 2: 输入: \"()[]{}\"输出: true 示例 3: 输入: \"(]\"输出: false 示例 4: 输入: \"([)]\"输出: false 示例 5: 输入: \"{[]}\"输出: true 解题思路 给定一段只包括 '('，')'，'{'，'}'，'['，']' 的字符串中，出现了一次左侧括号，那么下一次出现的右侧括号如果是与之对应的，输出 true，否则输出 false。字符串是空时，也要输出 true。 使用一个 map 保存括号的对应关系。 创建一个容器用于保存字符串中的左侧括号。 遍历字符串，每遇到一个左侧括号，就将该括号放入容器中。 如果遇到的符号是右侧括号，则判断容器A中最后一次添加的左侧括号，是否是与之对应的：如果是，则从容器中移除最后一次添加的左侧括号，然后继续执行；如果不是，则直接返回 false。 遍历结束后，如果容器中数据的个数为 0，那么返回 true 。有两种情况会得到 true 。 因为如果给定字符串长度为 0，则容器中数据的个数为 0，那么应该输出 true 。 左右括号为成对出现，最后容器中的数据全被移除了，也应该输出 true 。 代码 package main import \"fmt\" func main() { fmt.Println(isValid(\"()\")) } func isValid(s string) bool { symbolMap := map[string]string { \"(\": \")\", \"[\": \"]\", \"{\": \"}\", } stack := NewStack() for _, val := range s { character := string(val) if rightSymbol := symbolMap[character]; rightSymbol != \"\" { stack.Push(character) } else if symbolMap[stack.Pop()] != character { return false } } return 0 == stack.Length() } type Stack struct { data []string } func NewStack() *Stack { return &Stack{} } func (s *Stack) Push(item string) { s.data = append(s.data, item) } func (s *Stack) Pop() string { if s.Length() == 0 { return \"\" } else { lastCharacter := s.data[s.Length()-1] s.data = s.data[0:s.Length()-1] return lastCharacter } } func (s *Stack) Length () int { return len(s.data) } Title: 有效的括号 Date: 2019.11.09 Author: zhangpeng Github: https://github.com/fullstack-zhangpeng Copyright © zhang peng 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-07-22 10:44:14 "},"mac/update-git-version.html":{"url":"mac/update-git-version.html","title":"升级 Git 版本","keywords":"","body":"Mac 升级 Git 版本 不吹牛的说，这篇文章绝对是目前网上最简单的 Git 升级教程了 安装 Homebrew Homebrew 是一个软件包管理器。它的作用就是将软件包安装到自己的目录中，然后将其文件符号链接到 /usr/local。更多信息，请自行进入官网查看。 在将下面代码复制进终端，点击回车，然后打开零食，边吃边等就好。 /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" 升级 git 安装最新版的 git brew install git 当看到下面输出时，说明 git 已经安装完成： Already downloaded: /Users/zhangpeng/Library/Caches/Homebrew/downloads/c5f94c257b885992f680bbe3c2b8ec009e8856aefebac2cc1fb6608d7f006152--git-2.20.1.mojave.bottle.2.tar.gz ==> Pouring git-2.20.1.mojave.bottle.2.tar.gz ==> Caveats Bash completion has been installed to: /usr/local/etc/bash_completion.d zsh completions and functions have been installed to: /usr/local/share/zsh/site-functions Emacs Lisp files have been installed to: /usr/local/share/emacs/site-lisp/git ==> Summary 🍺 /usr/local/Cellar/git/2.20.1: 1,528 files, 41.3MB 改变默认 Git 指向 在终端中查看我们的 git 指向和版本信息。 ➜ ~ which git /usr/bin/git ➜ ~ git --version git version 2.17.2 (Apple Git-113) 接下来我们通过 brew link 将 git 指向我们通过 Homebrew 安装的 git ➜ ~ brew link git --overwrite Warning: Already linked: /usr/local/Cellar/git/2.20.1 To relink: brew unlink git && brew link git link 成功后，退出终端后，再次打开。然后查看 git 指向和版本信息。 ➜ ~ which git /usr/local/bin/git ➜ ~ git --version git version 2.20.1 可以看到，我们的 git 版本已经升级到最新版了。 Title: Mac 升级 Git 版本 Date: 2019.01.16 Author: zhangpeng Github: https://github.com/fullstack-zhangpeng Copyright © zhang peng 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-07-22 10:44:14 "},"mac/install-charles-certificate.html":{"url":"mac/install-charles-certificate.html","title":"Charles 安装证书","keywords":"","body":"Charles 安装证书 Charles 是什么 Charles 是一个 HTTP 代理服务器, HTTP 监视器,反转代理服务器，当浏览器连接 Charles 的代理访问互联网时，Charles 可以监控浏览器发送和接收的所有数据。它允许一个开发者查看所有连接互联网的 HTTP 通信，这些包括 request, response 和 HTTP headers（包含cookies与caching信息）。 Charles 能做什么 抓取 http 和 https 的请求和响应，这是最常用的。 重发网络请求，方便后端调试。 修改网络请求参数（客户端向服务器发送的时候，可以修改后再转发出去）。 网络请求的截获和动态修改。 支持模拟慢速网络，主要是模仿手机上的2G/3G/4G的访问流程。 支持本地映射和远程映射，比如你可以把线上资源映射到本地某个文件夹下，这样可以方便的处理一些特殊情况下的bug和线上调试（网络的css，js等资源用的是本地代码，这些你可以本地随便修改，数据之类的都是线上的环境，方面在线调试）。 可以抓手机端访问的资源（如果是配置HOST的环境，手机可以借用host配置进入测试环境）。 安装证书 通过菜单拦中的选项，我们可以安装整数： 给 PC 安装证书 安装证书 Help -> SSL Proxying -> Install Charles Root Certificate 在弹框中，根据自己的情况选择对应的钥匙串 信任证书 进入菜单，选择钥匙串访问，在搜索框中搜索 Charles ，找到 Charles Proxy CA。双击打开证书的信息界面，将红框中的选项改为始终信任。 给 iOS 模拟器安装证书 安装证书 Help -> SSL Proxying -> Install Charles Root Certificate in iOS Simulators 信任证书 Settings -> General -> About -> Certificate Trust Settings 打开 iOS Simulators 的证书信任选项 给手机安装证书 安装证书 Help -> SSL Proxying -> Install Charles Root Certificate on a Mobile Device or Remote Broswer 将手机和电脑都连接到同一无线局域网，进入无线局域网设置，手动设置代理 按照提示框中的提示, 在无线网设置中，将代理改为手动设置，按图中所示填写 xxx.xx.xxx.xxx:xxxx 使用手机浏览器访问 chls.pro/ssl，按照提示安装证书 信任证书 设置 -> 通用 -> 关于本机 -> 证书信任设置 打开刚刚安装的证书的信任选项 Title: Charles 安装证书 Date: 2019.01.02 Author: zhangpeng Github: https://github.com/fullstack-zhangpeng Copyright © zhang peng 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-07-22 10:44:14 "},"mac/a-better-terminal.html":{"url":"mac/a-better-terminal.html","title":"iTerm2 一个更好用的终端","keywords":"","body":"iTerm2 一个更好用的终端 本文意图是给终端小白提供一个 效(fang)率(bian)更(zhuang)高(bi) 的终端使用方式。 安装 iTerm2 下载iTerm2 进行常规安装 提(kai)高(shi)效(zhuang)率(bi)的方式 命令行工具 oh-my-zsh oh-my-zsh 是什么 oh-my-zsh是一款社区驱动的命令行工具，正如它的主页上说的，oh-my-zsh是一种生活方式。它基于zsh命令行，提供了主题配置，插件机制，已经内置的便捷操作。给我们一种全新的方式使用命令行。 oh-my-zsh这个名字听起来就很有意思，它是基于zsh命令行的一个扩展工具集，提供了丰富的扩展功能。 oh-my-zsh只是一个对zsh命令行环境的配置包装框架，但它不提供命令行窗口，更不是一个独立的APP。 详细介绍可以看它的主页oh-my-zsh。 oh-my-zsh 怎么安装 // Via curl sh -c \"$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\" // Via wget sh -c \"$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)\" oh-my-zsh 个性化配置 更换自己喜欢主题，可以百度找配置也可以使用官方提供的主题1、官方提供的主题2 安装插件，通过安装插件使 oh-my-zsh 更加强大。官方插件1、官方插件2，我这边常用的有一下几个： zsh-syntax-highlighting - 命令高亮 z - 快速跳转之前已经进入过的路径，会根据频率进行权重调整 命令高亮 命令行中的命令高亮是通过zsh-syntax-highlighting实现，安装 zsh-syntax-highlighting的方法有很多，具体可以查看 Install zsh-syntax-highlighting 如果您已经安装了oh-my-zsh，可以直接按照下面的步骤安装： 将 zsh-syntax-highlighting 克隆到指定文件夹 // Clone this repository in 'oh-my-zsh's plugins directory git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting 在~/.zshrc中的插件列表中添加插件 // Activate the plugin in `~/.zshrc` plugins=( [plugins...] zsh-syntax-highlighting) 编译 ~/.zshrc 后即可看到改变 // Source `~/.zshrc` to take changes into account source ~/.zshrc 让 iTerm2 变的色彩缤纷 让 iTerm2 是通过 coreutils 实现。 安装 coreutils // 通过brew安装 `coreutils` brew install xz coreutils 生成颜色定义文件 // 生成颜色定义文件 gdircolors --print-database > ~/.dir_colors 打开 ~/.zshrc，在您喜欢的位置添加下面代码 if brew list | grep coreutils > /dev/null ; then PATH=\"$(brew --prefix coreutils)/libexec/gnubin:$PATH\" alias ls='ls -F --show-control-chars --color=auto' eval `gdircolors -b $HOME/.dir_colors` fi 编译一下 ~/.zshrc 就可以看到效果了 // source ~/.zshrc source ~/.zshrc 附 iTerm2 利用Oh-My-Zsh打造你的超级终端 让Mac OS X的终端多姿多彩 Title: iTerm2 一个更好用的终端 Date: 2018.12.18 Author: zhangpeng Github: https://github.com/fullstack-zhangpeng Copyright © zhang peng 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-07-22 10:44:14 "},"mac/reinstall-mac-system.html":{"url":"mac/reinstall-mac-system.html","title":"Mac 系统重装","keywords":"","body":"Mac 系统重装 为什么要重装系统 无用的东西太多，忍不了了 在日常工作中，我们难免要安装各式各样的软件，插件，环境等，随着时间的推移，我们电脑中的东西越来越多，虽然不会引起卡顿，但是想想就觉得心里膈应，像我这种强迫症就会选择开始删。 但是删的时候就很麻烦了，App 从 Application 文件夹中删除后，还会有些配置文件保留在电脑中，很难完全移除。而插件，环境等，删除的操作就更为麻烦。 最后的最后就会有一部分人选择重装系统，因为他也不确定是不是删了什么不应该删的东西。 步入了Beta版的坑，忍不了了 世上永远少不了想要第一个吃螃蟹的人，新版系统一发布，便毫不犹豫的进行了升级，在使用一段时间后，发现坑太多，就不想被这些坑折磨了。 但是苹果爸爸会这么容易让一个小白鼠跑掉吗？不存在的！ 只有两条路可以选择： 等到更高版本的系统出现，进行升级需要在坑中再待一段时间，时间不确定。 重装回低版本的系统切记备份好所有的数据，因为这种方案要抹掉磁盘，即一切从零开始。 重装系统的几种方式 系统重装有以下几种方式，文中以苹果最新的系统 macOS High Sierra 为例。 从 App Store 安装 两种获取系统镜像的方式： 打开 App Store，搜索 macOS High Sierra 点击下载按钮 直接打开 macOS High Sierra 页面，点击下载按钮 下载完成后，安装器会自动打开，按照提示即可完成新系统的安装。 在线恢复 首先我们要通过组合键进入macOS恢复模式。根据不同的目标，我们可以按不同的组合键。 组合键 目标 Command + R 安装您在 Mac 上安装过的最新 macOS，但不会升级到更高的版本。 Option + Command + R 升级到与您的 Mac 兼容的最新 macOS Shift-Option-Command-R（需要安装 macOS Sierra 10.12.4 或更高版本） 安装 Mac 附带的 macOS 或最接近的仍可用版本。 进入恢复模式后，我们可以看到下面四个功能： 选择重新安装 macOS，根据提示我们就可以完成新系统的安装了。 注： 在系统安装之前，根据具体的情况，决定是否要通过磁盘工具抹掉磁盘。 从 macOS 恢复功能的实用工具窗口中选择“磁盘工具”，然后点按“继续”。 在“磁盘工具”边栏中选择您的设备或宗卷。 点按“抹掉”按钮或标签页。 弹框中的东西一般不需要我们修改，直接点击弹框中“抹掉”以开始抹掉磁盘。 完成后，退出“磁盘工具”以回到实用工具窗口。 U盘安装 下载系统镜像通过上面的方式，将我们需要的系统下载到电脑中，下载完成后，我们直接关闭安装界面，不要继续安装。这时我们可以在应用程序文件夹下看到我们刚刚下载的安装程序。 通过终端创建U盘启动器 首先我们要确认我们刚刚下载的安装程序的位置以及优盘的名字。 假设安装程序仍位于“应用程序”文件夹中，并且U盘名称是 MyVolume。 我们要在终端中使用 createinstallmedia 命令，输入命令后点击回车。 sudo /Applications/Install\\ macOS\\ High\\ Sierra.app/Contents/Resources/createinstallmedia --volume /Volumes/MyVolume --applicationpath /Applications/Install\\ macOS\\ High\\ Sierra.app 然后输入密码，密码是不会显示出来的，输入后点击回车。 接下来按着终端中的提示即可完成启动盘的制作。 使用U盘启动器安装新系统 将U盘查到电脑上 进入恢复模式，将启动磁盘改为我们制作的启动盘，启动盘的修改可以看考附件 从“实用工具”窗口中选择“安装 macOS”（或“安装 OS X”），然后点按“继续”，按照屏幕上的说明进行操作 附 苹果官方提供的 macOS 安装文档：如何安装 macOS 目前 macOS 的版本列表：macOS 版本列表 通过 App Store 安装 macOS High Sierra：如何下载安装 macOS High Sierra macOS U盘启动盘制作教程：如何创建可引导的 macOS 安装器 通过恢复模式安装新系统：macOS 恢复模式 两台 Mac 电脑间的数据迁移方法：如何将内容移至新 Mac 如何修改启动盘：如何选择其他启动磁盘 Title: Mac 系统重装 Date: 2018.06.16 Author: zhangpeng Github: https://github.com/fullstack-zhangpeng Copyright © zhang peng 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-07-22 10:44:14 "},"ubuntu/install-mysql.html":{"url":"ubuntu/install-mysql.html","title":"Ubuntu 安装 MySQL","keywords":"","body":"Ubuntu 安装 MySQL 下载安装 获取 mysql-apt-config 文件下载地址 进入 MySQL 官网，选择 APT Repository。 >>>直达链接 点击页面底部 Download 按钮，进入下载页。 复制页面底部 No thanks, just start my download. 的链接地址 上面得到的链接地址即为 mysql-apt-config 的下载地址。 本文发表之时的最新地址为：https://dev.mysql.com/get/mysql-apt-config_0.8.12-1_all.deb 安装 mysql-apt-config 在阅读下面的内容前，请先登录您的服务器。 #1.下载 mysql-apt-config sudo wget https://dev.mysql.com/get/mysql-apt-config_0.8.12-1_all.deb #2. 安装 mysql-apt-config sudo dpkg -i mysql-apt-config_0.8.12-1_all.deb 这时会有一个可视化界面出现，如下图所示。 选择第一项，可以看到让我们选择 MySQL 的版本，我这边选择的是 5.7 版本。然后一路 Ok 下去就可以了。 安装其他 mysql 相关服务 #1.升级列表中的软件包 sudo apt-get update #2.安装 mysql-server mysql-common mysql-client sudo apt-get install mysql-server mysql-common mysql-client 如果出现一个要求输入数据库密码的界面的话，那么按着提示进行操作（输入密码，再次输入密码，确认）。如果没有看到这个界面，也不必惊慌（反正我也没有看到这个界面…🙄️），下一小节会讲解如何设置密码。 MySQL 安装完成后会自动启动，可以通过 sudo service mysql status 检查运行状态，控制台中输下面的内容就表示 MySQL 正在运行。 $ service mysql status - mysql.service - MySQL Community Server Loaded: loaded (/lib/systemd/system/mysql.service; enabled; vendor preset: en Active: active (running) since Tue 2019-04-02 23:43:54 CST; 23h ago Process: 4434 ExecStart=/usr/sbin/mysqld --daemonize --pid-file=/run/mysqld/my Process: 4412 ExecStartPre=/usr/share/mysql/mysql-systemd-start pre (code=exit Main PID: 4436 (mysqld) Tasks: 28 (limit: 1113) CGroup: /system.slice/mysql.service └─4436 /usr/sbin/mysqld --daemonize --pid-file=/run/mysqld/mysqld.pid Apr 02 23:43:53 VM-0-15-ubuntu systemd[1]: Stopped MySQL Community Server. Apr 02 23:43:53 VM-0-15-ubuntu systemd[1]: Starting MySQL Community Server... Apr 02 23:43:54 VM-0-15-ubuntu systemd[1]: Started MySQL Community Server. 其他常用命令： #查看 MySQL 运行状态 sudo service mysql status #启动 MySQL 服务 sudo service mysql start #停止 MySQL 服务 sudo service mysql stop #重启 MySQL 服务 sudo service mysql restart 修改密码 MySQL 5.7 安装完成后普通用户不能进 mysql，原因：root 的 plugin 被修改成了 auth_socket，用密码登陆的 plugin 应该是 mysql_native_password，直接用 root 权限登录就不用密码,修改 root 密码和登录验证方式。 #切换到 root 用户，运行 MySQL 命令 $ sudo su & mysql mysql> select user, plugin from mysql.user; +------------------+-----------------------+ | user | plugin | +------------------+-----------------------+ | root | auth_socket | | mysql.session | mysql_native_password | | mysql.sys | mysql_native_password | | debian-sys-maint | mysql_native_password | +------------------+-----------------------+ 4 rows in set (0.00 sec) mysql> update mysql.user set authentication_string=PASSWORD('123456'), plugin='mysql_native_password' where user='root'; mysql> flush privileges; #退出 MySQL mysql> exit Bye #重启 MySQL $ sudo /etc/init.d/mysql restart 通过上面的代码，就将 MySQL 的密码设置成了 123456，我们可以检查下密码是否设置成功： #登录 MySQL $ mysql -uroot -p Enter password: Welcome to the MySQL monitor. Commands end with ; or \\g. Your MySQL connection id is 2 Server version: 5.7.22-0ubuntu18.04.1 (Ubuntu) Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved. Oracle is a registered trademark of Oracle Corporation and/or its affiliates. Other names may be trademarks of their respective owners. Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement. mysql> 新增用户 执行新增用户的 SQL 语句 mysql> create user 'zhangpeng'@'%' identified by '123456'; Query OK, 0 rows affected (0.08 sec) 注： 'zhangpeng'@'%'表示 zhangpeng 这个账号允许远程登录。 如果写成 'zhangpeng'@'localhost' ，那么只能本地登录。 设置字符集 MySQL 的默认字符集不是utf8，因此我们需要修改 MySQL 的字符集。 编辑配置文件（/etc/mysql/mysql.conf.d/mysqld.cnf），将下面内容填入配置文件。 [client] port = 3306 socket = /var/lib/mysql/mysql.sock default-character-set=utf8 [mysqld] port = 3306 socket = /var/lib/mysql/mysql.sock character-set-server=utf8 [mysql] no-auto-rehash default-character-set=utf8 修改完毕后，检查字符集是否设置成功 mysql> show variables like 'char%'; +--------------------------+----------------------------+ | Variable_name | Value | +--------------------------+----------------------------+ | character_set_client | utf8 | | character_set_connection | utf8 | | character_set_database | utf8 | | character_set_filesystem | binary | | character_set_results | utf8 | | character_set_server | utf8 | | character_set_system | utf8 | | character_sets_dir | /usr/share/mysql/charsets/ | +--------------------------+----------------------------+ 8 rows in set (0.17 sec) 远程登录 # 修改配置文件，注释掉 bind-address = 127.0.0.1 $ sudo vi /etc/mysql/mysql.conf.d/mysqld.cnf 保存退出，然后进入mysql服务，执行授权命令： $ mysql -uroot -p mysql> grant all on *.* to root@'%' identified by '123456' with grant option; Query OK, 0 rows affected, 1 warning (0.00 sec) mysql> flush privileges; Query OK, 0 rows affected (0.00 sec) mysql> exit Bye $ sudo /etc/init.d/mysql restart 附 Linux 常用命令集合 Ubuntu18.04 下安装 MySQL5.7 Title: Ubuntu 安装 MySQL Date: 2019.04.03 Author: zhangpeng Github: https://github.com/fullstack-zhangpeng Copyright © zhang peng 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-07-22 10:44:14 "},"learn/judge-algorithm-quality.html":{"url":"learn/judge-algorithm-quality.html","title":"如何评判算法好坏","keywords":"","body":"如何评判算法好坏 算法好坏可以通过下面两个纬度进行评判： 时间复杂度 评估执行程序的次数（执行时间） 空间复杂度 评估执行程序所需的存储空间 时间复杂度和空间复杂度描述方式 一般用 大O表示法 来描述复杂度，表示 数据规模n 对应的复杂度。不过要注意 大O表示法 仅仅是一种粗略的分析模型，是一种估算，用来帮助我们在短时间内了解一个算法的执行效率。 时间复杂度 时间复杂度又称\"渐进式时间复杂度\"，用来表示代码执行时间与数据规模之间的增长关系。 时间复杂度的推倒步骤： 找出算法中的基本语句 算法中执行次数最多的那条语句就是基本语句，通常是最内层循环的循环体。 计算基本语句的执行次数的数量级 只需计算基本语句执行次数的数量级，这就意味着只要保证基本语句执行次数的函数中的最高次幂正确即可，可以忽略所有低次幂和最高次幂的系数。这样能够简化算法分析，并且使注意力集中在最重要的一点上：增长率。可以简单概括为忽略常数、系数、低阶。 用大Ο记号表示算法的时间性能 将基本语句执行次数的数量级放入大Ο记号中。 简单举几个推倒大O表达式的例子： $9$ => $O(1)$ $2n + 3$ => $O(n)$ $n^2 + 2n + 3$ => $O(n^2)$ $4n^3 + 3n^2 + 22n + 100$ => $O(n^3)$ $5log_2n+20$ => $O(logn)$ $2n+3nlog_2n+19$ => $O(nlogn)$ $2n$ => $O(2^n)$ 常见的算法时间复杂度 由小到大依次为：常量阶 $O(1)$ 空间复杂度 空间复杂度，又称\"渐进空间复杂度\"，用来表示代码存储空间与数据规模之间的增长关系。。 空间复杂度包含三个部分：输入数据所占的存储空间，程序本身所占的空间，算法执行过程中所需的存储空间。 我们谈的空间复杂度，一般都是在讨论第三个部分，即算法执行过程中所需的存储空间。因为前两个部分，与算法并无太大关系，是由输入数据的规模以及编译链接后生成的可执行程序的大小决定。 空间复杂度的推倒规则： 当一个算法的需要的空间为一个常量，即不随被处理 数据规模n 的大小而改变时，可表示为 $O(1)$ 当一个算法的需要的空间和 数据规模n 成正比，可表示为 $O(n)$ 当然像 $O(n^2)、O(n^3)、O(logn)、O(nlogn)$ 也有，不过很少见。 如何优化算法 用尽量少的存储空间 用尽量少的执行步骤 根据具体情况，选择空间换时间或时间换空间 参考文献 大O表示法 如何理解算法的空间复杂度？ Title: 如何评判算法好坏 Date: 2020.07.22 Author: zhangpeng Github: https://github.com/fullstack-zhangpeng Copyright © zhang peng 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-07-22 10:44:14 "},"learn/keep-alive-ssh.html":{"url":"learn/keep-alive-ssh.html","title":"如何保持 SSH 服务不掉线","keywords":"","body":"如何保持 SSH 服务不掉线 常见的保持 SSH 服务不掉线的方法有两种： 服务端发送心跳包 客户端发送心跳包 本篇文章将以 Ubuntu 18.04.4 LTS 为例，分别对以上两种方法进行讲解。 服务端发送心跳包 登陆您的服务器后，打开 /etc/ssh/sshd_config 文件。 将 ClientAliveInterval 和 ClientAliveCountMax 前面的 # 去掉。（如果没有则添加这两个字段） 将 ClientAliveInterval 的值修改为 60，ClientAliveCountMax 的值修改为 6 保存上述修改，如果提示 'readonly' option is set (add ! to override)，请以系统管理者的身份执行指令。 重启 SSH 服务 ClientAliveInterval 服务器端向客户端请求消息的时间间隔，单位为秒，默认是 0，不发送ClientAliveCountMax 服务器发出请求后，客户端没有响应的重试次数，到达次数后断开 客户端发送心跳包 进入客户端的 ~/.ssh/ 文件夹 打开 config 文件，如果没有请创建 在 config 文件中添加以下内容，然后保存ServerAliveInterval 20ServerAliveCountMax 999 ServerAliveInterval 客户端向服务器端请求消息的时间间隔，单位为秒，默认是 0，不发送ServerAliveCountMax 客户端发出请求后，服务器没有响应的重试次数，到达次数后断开 总结 两种方式均可以实现 SSH 服务不掉线，可以根据自己的情况进行选择。 一台服务器，多台客户端 可以在用服务端发送心跳包的方法。这样就不需要在每台客户端上进行修改。 一台客户端，多台服务器 可以在用客户端发送心跳包的方法。这样就不需要在每台服务器上进行修改。 Title: 如何保持 SSH 服务不掉线 Date: 2020.03.01 Author: zhangpeng Github: https://github.com/fullstack-zhangpeng Copyright © zhang peng 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-07-22 10:44:14 "},"learn/introduction-to-shell.html":{"url":"learn/introduction-to-shell.html","title":"Shell 入门教程","keywords":"","body":"Shell 入门教程 本文为译文，原文链接：shell shell是一个高效的、文本化的计算机接口。 shell提示符：当你打开终端时看到的一切。可以让用户执行的程序和命令，常见的有： cd改变目录 ls列出文件和目录 mv和cp移动和复制文件 但是shell允许您做更多的事情；您可以调用计算机上的任何程序，并且命令行工具的存在就是为了完成您可能想做的任何事情。他们往往比他们的图形对手更有效率。我们这门课会讲到很多。 shell提供交互式编程语言 (\"脚本\")。有很多种shell： 您可能用过sh或者bash 和语言相关的shell：csh 或者更好用的shell：fish，zsh，ksh 在这个课堂上，我们将关注无处不在的sh和bash，但是使用其他的shell感觉更好。我喜欢fish。 在您的工具箱中，shell程序是一个非常有用的工具。可以直接在提示符下编写程序，也可以将程序写入文件。 通过#!/bin/sh+chmod +x将shell程序变成可以执行的 使用shell工作 将一个命令运行多次： for i in $(seq 1 5); do echo hello; done 有很多东西可以展开来讲： for x in list; do BODY; done ;终止一个命令 -- 相当于换行 遍历list，将每个值赋值给x，然后运行 分割标志符是“空格”，我们稍后会讲到 shell中没有花括号，所以使用do+done $(seq 1 5) 运行seq命令，参数分别为1和5 使用括号内命令的输出替换 $() 相当于 for i in 1 2 3 4 5 echo hello shell脚本中的所有内容都是命令 在本例中，运行echo命令，将打印该命令的参数hello 所有命令都可以在$PATH搜索到 我们可以举个例子： for f in $(ls); do echo $f; done 将打印当前目录中的每个文件名。可以使用=设置变量的值（=两边不需要空格） foo=bar echo $foo 这里也有一些特殊的变量： $1-$9：脚本的参数 $0：脚本的名称 $#：脚本的参数个数 $$：当前脚本的进程ID 只打印目录 for f in $(ls); do if test -d $f; then echo dir $f; fi; done 这里展开来讲： if CONDITION; then BODY; fi CONDITION是一个命令，如果返回时为0(success)，就会执行BODY 也可以继续执行else或者elif 同样，没有花括号，所以使用then和fi test是另外一个命令，提供各式各样的检查与对比功能，退出时会返回对比结果，如果为真，则返回0($?) man COMMAND会对您有很大的帮助，比如：man test 也可以使用[+]执行，比如：[ -d $f ] 查看一下man test和which [的执行结果 可是等等！结果是错误的！如果有个文件叫做“我的文档怎么办”？ for f in $(ls)展开为for f in My Documents 先以My为test的执行参数，然后以Documents作为参数 这不是我们想要的！ shell脚本中导致出现问题最多的原因 参数分割 Bash是通过空格分割参数；但这并不总是您想要的！ 需要使用引号处理for f in \"My Documents\"中f的空格，才能正确的执行 其他地方也有同样的问题，您看到过吗？比如test -d $f：如果$f中包含空格，test将会发生错误！ echo碰巧没有问题，因为按空格分隔联接，但是如果文件名包含换行符，怎么办？！变成空格！ 引号用于所有不希望被拆分的参数 我们该如何修复上面的脚本呢？您认为for f in \"$(ls)\"怎么样？ 答案是通配符！ Bash知道如何使用模板查找文件： * 任意字符串 ? 任意字符 {a,b,c} 这些字符中的任意一个 for f in *：这个文件夹下所有的文件 在使用通配符时，每个匹配的文件都将变成自己的参数 在使用时，仍需要确保引号的正确使用：test -d \"$f\" 可以使用这些提高通配符效率： for f in a*: 当前文件夹下，所有以a开头的文件 for f in foo/*.txt:foo文件夹下，所有以.txt结尾的文件 for f in foo/*/p??.txt: 在foo的子文件夹下，以p开头的三个字母的文件 空格的问题不止于此： if [ $foo = \"bar\" ]; then-- 看看这个问题？ 如果$foo是空的呢？[的参数是=和bar... 可以用[ x$foo = \"xbar\" ]来解决这个问题，但是效率低 相反，使用[[：一个bash内置的具有特殊解析的比较器 也可以使用&&代替-a，-o连接||等等 可组合性 Shell之所以强大，部分原因在于它的可组合性。可以将多个程序链接在一起，而不是让一个程序做每一件事情。 关键字是|。 a|b表示同时运行a和b，将a的所有输出，当作b的输入，打印b的输出。 您启动的所有程序(“进程”)都有三个“流”: STDIN：当程序读取输入时，它从这里开始 STDOUT：当程序打印东西时，它就在这里 STDERR：程序可以选择使用的第二个输出 默认的，STDIN是您的键盘输入，STDOUT和STDERR都是您的终端。但是您可以改变他们！ a | b将a的输出当作b的输入 同样还有： a > foo（将a的标准输出写入foo文件） a 2> foo（将a的标准错误输出写入foo文件） a （a的标准输入是从foo文件读取的） 提示：tail -f将打印文件内容，即使他正在被写入 为什么这个这么有用？您亲自试试下面程序的输出！ ls | grep foo：包含单词foo的所有文件 ps | grep foo：包含单词foo的所有进程 journalctl | grep -i intel | tail -n5：最后5条带有intel(不区分大小写)的系统日志消息 who | sendmail -t me@example.com：将登录用户列表发送到me@example.com 形成了许多数据处理的基础，稍后我们将讨论它 Bash还提供了许多其他编写程序的方法。 您可以组合形成一个命令(a; b) | tac：先运行a，然后运行b，然后把他们的所有输出当作tac命令的输入，tac是一个将输入反序的命令。 一个不太为人所知但超级有用的方法是过程替换。b 将运行a，为输出流生成一个临时文件名，并将该文件名传递给b。举个例子： diff 将向您展示前一个引导日志的前20行与更前一个引导日志的前20行之间的区别。 任务和进程控制 如果您在后台执行周期更长的任务呢？ 在后台运行的程序是以&结尾 它会立即给你提示 如果你想同时运行两个程序，比如服务器和客户端，这很好解决：server & client 注意：正在运行的程序仍将终端设置为标准输出，试一试：server > server.log & client 通过jobs查看所有的进程 注意现实Running的 使用fg %JOB将其放到前台(没有参数是最新的) 如果您想将当前的程序放入后台：^Z+bg(这里的^Z代表按Ctrl+Z) ^Z将当前的进程停止，并将它变成一个job bg将最新的job在后台运行（就像使用了&） 后台jobs仍然绑定到当前会话，如果注销，则退出。您可以使用disown或者nohup切断这种绑定关系。 $!是最后一个后台进程的pid 在你的电脑上运行的其他东西呢? ps很好用：列出正在运行的进程 ps -A：打印所有用户的进程（也包括ps ax） ps有很多参数：可以通过man ps查看 pgrep：搜索进程（和ps -A | grep类似） pgrep -af：通过参数搜索和显示 kill：通过ID向进程发送信号（pkill by search + -f） 信号告诉进程“做什么事” 最常见:SIGKILL(-9或-KILL)：立刻退出，相当于^\\ 还有：SIGTERM(-15or-TERM)：立刻优雅的退出，相当于^C 标志符 大多数命令行程序都使用标志符接受参数。标志符通常有短形式(-h)和长形式(--help)。通常运行CMD -h或man CMD会给你展示该CMD可用的标识符的列表。短标志通常可以组合使用，运行rm -r -f相当于运行rm -rf或者rm -fr。一些常见的标识符是有约定俗成的标准的，您会发现它们在很多命令中： -a一般指所有文件（也包括那些以点开头的） -f通常指强制做什么事情，比如说rm -f -h大多数命令都是显示帮助 -v通常启用详细输出 -V通常打印命令的版本 此外，双破折号--用于内置命令和许多其他命令中，表示命令选项的结束，之后只接受位置参数。因此，如果您有一个可以使用-v参数的文件(文件类型支持使用)，并且想要grep它，grep pattern -- -v可以，但是grep pattern -v不行。事实上，创建这种文件的方法是touch -- -v。 附录 Shell Shell笔记 Shell 中各种括号的作用 Shell test 命令 Title: Shell 入门教程 Date: 2019.02.17 Author: zhangpeng Github: https://github.com/fullstack-zhangpeng Copyright © zhang peng 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-07-22 10:44:14 "},"learn/introduction-to-appleScript.html":{"url":"learn/introduction-to-appleScript.html","title":"AppleScript 入门与实践","keywords":"","body":"AppleScript 入门与实践 AppleScript 是 Mac OS X 内置的一种功能强大的脚本语言。 官方介绍 AppleScript Overview AppleScript Language Guide AppleScript 例子 发送邮件：sendMail.scpt 发送iMessage：sendMessage.scpt 本文的所有代码均以上传至 GitHub，如需自取~ Title: AppleScript 入门与实践 Date: 2018.05.23 Author: zhangpeng Github: https://github.com/fullstack-zhangpeng Copyright © zhang peng 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-07-22 10:44:14 "},"learn/set-up-hexo-blog.html":{"url":"learn/set-up-hexo-blog.html","title":"搭建 Hexo Blog","keywords":"","body":"搭建 Hexo Blog Hexo 需要 Git 和 Node 的支持，所以烦请各位想用 Hexo 搭建博客的同学自行安装 Git 和 Node，然后再来阅读本文档。 安装 hexo 脚手架 ➜ ~ npm install -g hexo-cli /usr/local/bin/hexo -> /usr/local/lib/node_modules/hexo-cli/bin/hexo + hexo-cli@3.1.0 added 67 packages from 317 contributors in 6.685s 如果因为权限问题安装失败的，那么在命令前添加 sudo，输入密码后就可以安装了 通过 hexo -v 可以检查 hexo-cli 是否安装成功 ➜ ~ hexo -v hexo-cli: 3.1.0 os: Darwin 19.0.0 darwin x64 node: 12.12.0 v8: 7.7.299.13-node.12 uv: 1.32.0 zlib: 1.2.11 brotli: 1.0.7 ares: 1.15.0 modules: 72 nghttp2: 1.39.2 napi: 5 llhttp: 1.1.4 http_parser: 2.8.0 openssl: 1.1.1d cldr: 35.1 icu: 64.2 tz: 2019a unicode: 12.1 创建 hexo 博客 通过终端进入您想要创建博客的文件夹中，执行初始化命令： hexo init 创建完毕后，我们可以看到生成了很多的文件及文件夹，如下： 其中比较主要的有： . ├── source //用于存放博客的 markdown 文件，以及静态文件 │ └── _posts //博客的 markdown 文件 ├── themes //存放博客主题 └── _config.yml //我们博客的配置文件，可以配置title、主题、发布地址等 到这里，博客基本算是创建完毕了。 预览博客 在终端中，执行 hexo s 启动服务器，我们就可以在浏览器中看到我们博客了。默认情况下，访问网址为 http：//localhost：4000/。 发布博客 本章讲述的是将博客发布到 GitHub 上，如果想发布到自己的服务器上，请酌情修改，基本上大同小异。 建立一个博客仓库 我们需要准备一个 GitHub 账号 首先我们需要一个GitHub账号，我想大家应该都有这个吧，如果没有请自行申请，这里我就不做赘述了。 创建一个用于存放博客的仓库 网上大多数的人都建议创建一个如图所示的项目，即xxx.github.io，红框中的内容与账户名保持一致。PS.忽略图中红色的报错，我这边报错是因为我已经创建了相同名字的项目✧(≖ ◡ ≖✿) 小声哔哔：通过我的测试，其实项目起什么名字并不重要，都可以访问到，我觉得大多数人以xxx.github.io当项目名字，只是为了后期访问好看罢了🙄 安装博客发布工具 为了方便快捷的将我们本地的博客发布到 GitHub 上，建议大家安装 hexo-deployer-git 自动部署发布工具。 安装插件 在博客的根目录执行 npm install hexo-deployer-git --save 修改配置文件 发布工具安装完毕后，我们还需要在_config.yml文件中配置一下我们的GitHub的地址，否则我们上传到哪去呢，是不是？ 打开_config.yml文件，搜索deploy，这个就是我们要配置的地方了，如果没有就在文件的最后添加下面的代码。 deploy： type： git repo： github上的项目地址 注： 1.上面的配置中，冒号和你填写的内容间一定要有个空格，这是标准的格式，没得谈！！！ 2.有的同学可能会问可不可以发布到某个分支上，答案是不能。原因请看下图，箭头所指处，明确说明User pages must be built from the master branch. 编译&部署博客 接下来就剩下发布这一步了，在终端中进入博客的根目录，执行： hexo clean && hexo g && hexo d 当您看到 INFO Deploy done： git 时，就说明您的博客成功发布到GitHub上了，通过访问 http：//xxx.github.io/，就可以访问到您的博客了，记得把 xxx 换成您的项目名。 日常更新博客 当新写了博客文章，或者是修改了主题，仅需通过终端，进入本地博客的根目录，执行hexo clean && hexo g && hexo d。然后就可以在博客中看到最新的文章或是主题了。 附 具体Hexo的命令，可以在Hexo官网中找到 Title: 搭建 Hexo Blog Date: 2017.11.26 Author: zhangpeng Github: https://github.com/fullstack-zhangpeng Copyright © zhang peng 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-07-22 10:44:14 "},"basicknowledge/date-formatter.html":{"url":"basicknowledge/date-formatter.html","title":"常用的日期格式化格式","keywords":"","body":"常用的日期格式化格式 Format Description Example \"y\" 1 digit min year 1, 42, 2017 \"yy\" 2 digit year 01, 42, 17 \"yyy\" 3 digit min year 001, 042, 2017 \"yyyy\" 4 digit min year 0001, 0042, 2017 \"M\" 1 digit min month 7, 12 \"MM\" 2 digit month 07, 12 \"MMM\" 3 letter month abbr. Jul, Dec \"MMMM\" Full month July, December \"MMMMM\" 1 letter month abbr. J, D \"d\" 1 digit min day 4, 25 \"dd\" 2 digit day 04, 25 \"E\", \"EE\", \"EEE\" 3 letter day name abbr. Wed, Thu \"EEEE\" full day name Wednesday, Thursday \"EEEEE\" 1 letter day name abbr. W, T \"EEEEEE\" 2 letter day name abbr. We, Th \"a\" Period of day AM, PM \"h\" AM/PM 1 digit min hour 5, 7 \"hh\" AM/PM 2 digit hour 05, 07 \"H\" 24 hr 1 digit min hour 17, 7 \"HH\" 24 hr 2 digit hour 17, 07 \"m\" 1 digit min minute 1, 40 \"mm\" 2 digit minute 01, 40 \"s\" 1 digit min second 1, 40 \"ss\" 2 digit second 01, 40 \"S\" 10th's place of fractional second 123ms -> 1, 7ms -> 0 \"SS\" 10th's & 100th's place of fractional second 123ms -> 12, 7ms -> 00 \"SSS\" 10th's & 100th's & 1,000's place of fractional second 123ms -> 123, 7ms -> 007 Title: 常用的日期格式化格式 Date: 2019.11.08 Author: zhangpeng Github: https://github.com/fullstack-zhangpeng Copyright © zhang peng 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-07-22 10:44:14 "},"basicknowledge/introduction-to-restful.html":{"url":"basicknowledge/introduction-to-restful.html","title":"RESTful 笔记","keywords":"","body":"RESTful 笔记 REST 是什么 REST 这个词是出自 Roy Thomas Fielding 的一篇论文，如果有兴趣了解，可以查阅 REST相关章节。 REST，并不是简单的四个字母，它是 Representational State Transfer 的缩写，可译为\"表现层状态转化”。 看不懂没关系，在前面加一个 Resource，就可以很好的理解了：资源在网络中以某种表现形式进行状态转移 Resource 这边的 Resource 指的就是我们的资源、数据等，可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。 Representational 资源的表现形式，比如我们常见的： 数据：HTML格式、XML格式、JSON格式、二进制格式等； 图片：JPG格式、PNG格式等； 具体表现形式，在 HTTP 请求的头信息中用 Accept 和 Content-Type 字段指定 State Transfer 客户端和服务器的一个互动过程，势必涉及到数据和状态的变化。 互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生\"状态转化\"。而这种转化是建立在表现层之上的，所以就是\"表现层状态转化\"。 RESTful API 遵守了 REST 原则的 API 特点 每个URL表示一种资源 URL语义清晰明确，不出现动词，只有名词复数（操作的动词是通过请求方式来表示） 使用HTTP的方法来表示对资源的增删改查 GET（常用）：从服务器上获取一个具体的资源或者一个资源列表。安全且幂等 POST（常用）： 在服务器上创建一个新的资源。不安全且不幂等 PUT（常用）：以整体的方式更新服务器上的一个资源。不安全但幂等 DELETE（常用）：删除服务器上的一个资源。不安全但幂等 PATCH：只更新服务器上一个资源的一个属性。 HEAD： 获取一个资源的元数据，如数据的哈希值或最后的更新时间 OPTIONS：获取客户端能对资源做什么操作的信息。 使用HTTP的状态来表示结果 200 OK 400 Bad Request 500 Internal Server Error 幂等：无边际效应，多次操作得到相同的结果 简单来讲就是： 看 Url 就知道要什么 看 http method 就知道干什么 看 http status code 就知道结果如何 优点 透明性，暴露资源存在。 充分利用 HTTP 协议本身语义。 无状态，这点非常重要。在调用一个接口（访问、操作资源）的时候，可以不用考虑上下文，不用考虑当前状态，极大的降低了复杂度HTTP。 本身提供了丰富的内容协商手段，无论是缓存，还是资源修改的乐观并发控制，都可以以业务无关的中间件来实现。 附 理解RESTful架构 RESTful API 编写指南 如何给老婆解释什么是RESTful GitHub API Microsoft REST API Guidelines Title: RESTful 笔记 Date: 2019.03.26 Author: zhangpeng Github: https://github.com/fullstack-zhangpeng Copyright © zhang peng 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-07-22 10:44:14 "},"basicknowledge/http-status-code.html":{"url":"basicknowledge/http-status-code.html","title":"HTTP 状态码","keywords":"","body":"HTTP 状态码 1** 代表请求已被接受，需要继续处理。 2** 代表请求已成功被服务器接收、理解、并接受。 3** 代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址。 4** 代表客户端可能发生了错误，妨碍了服务器的处理。 5** 代表服务器在处理请求的过程中有错误或者异常状态发生。 Title: HTTP 状态码 Date: 2019.02.22 Author: zhangpeng Github: https://github.com/fullstack-zhangpeng Copyright © zhang peng 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-07-22 10:44:14 "},"basicknowledge/bit-operation.html":{"url":"basicknowledge/bit-operation.html","title":"简明扼要带你学位运算","keywords":"","body":"简明扼要带你学位运算 位运算是什么 二进制是计算技术中广泛采用的一种数制。二进制数据是用0和1两个数码来表示的数。它的基数为2，进位规则是“逢二进一”，借位规则是“借一当二”。当前的计算机系统使用的基本上是二进制系统。 直接对二进制数据进行操作，就称为位运算。 位运算的运算方式 与：& 运算规则： 相同位的两个数字都为1，则为1；若有一个不为1，则为0。 运算示例： 0 0 1 0 1 1 1 0 46 1 0 0 1 1 1 0 1 157 ——————————————— 0 0 0 0 1 1 0 0 12 或：| 运算规则： 相同位只要一个为1即为1。 运算示例： 0 0 1 0 1 1 1 0 46 1 0 0 1 1 1 0 1 157 ——————————————— 1 0 1 1 1 1 1 1 191 异或：^ 运算规则： 相同位不同则为1，相同则为0。 运算示例： 0 0 1 0 1 1 1 0 46 1 0 0 1 1 1 0 1 157 ——————————————— 1 0 1 1 0 0 1 1 179 取反：~ 运算规则： ~是一元运算符，用来对一个二进制数按位取反，即将0变1，将1变0。 运算示例： 0 0 1 0 1 1 1 0 46 ——————————————— 1 1 0 1 0 0 0 1 225 左移： 运算规则：a 运算示例： 0011 0110 右移：>> 运算规则：各二进位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补0（逻辑右移） 运算示例： 0110 >> 1 => 0011 位运算在日常开发中应用 位移枚举 在 iOS 中，我们有两个枚举类型：NS_OPTION 和 NS_ENUM。他们两个的本质都是一样的，核心差异就在于是否可以多选。 NS_OPTION：多个枚举值同时使用按位或 (|) 相加表示进行多选操作。位移不同位数得到值不同即数值代表的枚举值不同, 多个枚举同时使用仍具有唯一性。 NS_ENUM：不可多选，唯一互斥性。 位移枚举是什么 位移枚举是一种特殊的枚举，它和普通的枚举的差异就在于是否可以多选。 位移枚举的多个枚举值同时使用按位或( | )相加表示进行多选操作。位移不同位数得到值不同即数值代表的枚举值不同,多个枚举同时使用仍具有唯一性。 举例 自定义一个视图 AddLabelView ，创建一个属性，用于定义在什么位置添加 label 。 // AddLabelView typedef NS_OPTIONS(NSUInteger, AddLabelPosition) { AddLabelTopLeft = 1 创建一个我们自定义的视图，通过 addLabelPosition，控制我们在什么位置显示一个 label 。 AddLabelView *view = [[AddLabelView alloc] initWithFrame:CGRectMake(100, 100, 200, 200)]; view.addLabelPosition = AddLabelTopRight | AddLabelBottomRight | AddLabelBottomLeft; [self.view addSubview:view]; 通过上面的代码，您应该已经明白了位移枚举的多选是什么概念了，如果真的不明白，欢迎私信。 交换两个变量的值 有两个数字 a 和 b，如何不通过第三个变量交换 a 和 b的值？ a^=b 即 a=(a^b); b^=a 即 b=b^(a^b) ，由于^运算满足交换律，b^(a^b)=b^b^a 。由于一个数和自己异或的结果为0并且任何数与0异或都会不变的，所以此时b被赋上了 a 的值。 a^=b 就是 a=a^b，由于前面二步可知 a=(a^b)，b=a，所以 a=a^b即a=(a^b)^a 。故 a 会被赋上b的值。 代码如下： int a = 10; int b = 20; if (a != b) { a ^= b; b ^= a; a ^= b; } NSLog(@\"a: %@ -- b: %@\", @(a), @(b)); // 输出结果为 // a: 20 -- b: 10 判断奇偶 我们可以根据最未位是0还是1来决定，为0就是偶数，为1就是奇数。因此可以用 ((a & 1) == 0) 代替 (a % 2 == 0) 来判断数字是奇数还是偶数。 for (int i = 0; i 变换符号 变换符号简单来讲就是正数变复数，复数变正数。通过对数字取反加1就可以完成符号的变换。 int a = -10; NSLog(@\"a 变换符号后为：%@\", @(~a + 1)); // 输出结果为 // a 变换符号后为：10 附 位操作基础篇之位操作全面总结 位运算 C语言位运算符：与、或、异或、取反、左移和右移 位移枚举 Title: 简明扼要带你学位运算 Date: 2018.09.06 Author: zhangpeng Github: https://github.com/fullstack-zhangpeng Copyright © zhang peng 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-07-22 10:44:14 "},"basicknowledge/uri-url-urn.html":{"url":"basicknowledge/uri-url-urn.html","title":"URI、URL的差异与联系","keywords":"","body":"URI、URL、URN 的差异与联系 在开发过程中，经常见到有同事把链接命名为 uri_xxx_yyy 或者 url_xxx_yyy，可是uri和url分别是什么意思呢？希望在阅读这篇文章后，您可以明白～ URI URI全称为 Universal Resource Identifier，统一资源标识符，用来唯一的标识一个资源。 在电脑术语中，统一资源标识符（Uniform Resource Identifier，或URI)是一个用于标识某一互联网资源名称的字符串。 该种标识允许用户对任何（包括本地和互联网）的资源通过特定的协议进行交互操作。URI 由包括确定语法和相关协议的方案所定义。Web上可用的每种资源（HTML文档、图像、视频片段、程序等）由一个通用资源标识符（Uniform Resource Identifier, 简称\"URI\"）进行定位。 通常由下面几部分组成： 访问资源的命名机制 存放资源的主机名 资源自身的名称，由路径表示，着重强调于资源。 URL URL全称为 Universal Resource Locator，统一资源定位符，用来标识一个资源。 URL 通常以协议(http)开头，包含网络主机名 (example.com) 和文档路径 (/foo/mypage.html) 等信息。URL 还可能具有查询参数和锚点标识符。 统一资源定位符是对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。 通常由下面几部分组成： 协议(或称为服务方式) 存有该资源的主机IP地址(有时也包括端口号) 主机资源的具体地址。如目录和文件名等 URN URN全称为 Universal Resource Name，统一资源名称，用来定位的标识一个资源。 通过唯一且持久的名称来标识资源，但不一定告诉你如何在互联网上找到它。 URN不仅限于识别文件，还可以识别想法和概念。当URN确实代表文档时，可以通过“解析器”将其翻译成URL。然后可以从URL下载文档。 统一资源名称 (Uniform Resource Name, URN)，唯一标识一个实体的标识符，但是不能给出实体的位置。系统可以先在本地寻找一个实体，在它试着在Web上找到该实体之前。它也允许Web位置改变，然而这个实体却还是能够被找到。 通常以前缀urn开头 区别与联系 首先我们要弄清楚一件事：URL 和 URN 都是 URI 的子集。 换言之，URL 和 URN都是 URI，但是 URI 不一定是 URL 或者 URN。为了更好的理解这个概念，看下面这张图片。 URI 负责识别，URL 负责定位;然而，定位符也是标识符的一种，因此每个 URL 都是 URI，但是每个 URI 并不全是 URL。 二者的区别在于，URI表示请求服务器的路径，定义这么一个资源。而URL同时说明要如何访问这个资源（http://）。 一句话解释：URI 和 URL 都定义了 what the resource is。URL 还定义了 how to get the resource。 可以举个例子解释： 身份证号：类似于 URI，通过身份证号能让我们能且仅能确定一个人。 身份证地址：类似于URL://地球/中国/浙江省/杭州市/西湖区/某大学/14号宿舍楼/525号寝/张三.人可以看到，这个字符串同样标识出了唯一的一个人，起到了URI的作用，所以URL是URI的子集。 参考文献 W3C-URIs, URLs, and URNs HTTP 协议中 URI 和 URL 有什么区别？ 这三个你懂不懂？URL & URI & URN URL 和 URI 有什么不同? Title: URI、URL、URN 的差异与联系 Date: 2018.02.24 Author: zhangpeng Github: https://github.com/fullstack-zhangpeng Copyright © zhang peng 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-07-22 10:44:14 "}}